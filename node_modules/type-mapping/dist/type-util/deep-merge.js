"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var to_type_str_1 = require("./to-type-str");
var strict_equal_1 = require("./strict-equal");
var is_primitive_1 = require("./is-primitive");
function deepMergeImpl(a, b) {
    if (strict_equal_1.strictEqual(a, b)) {
        return a;
    }
    if (is_primitive_1.isPrimitive(a) || is_primitive_1.isPrimitive(b)) {
        throw new Error("Cannot merge " + to_type_str_1.toTypeStr(a) + " and " + to_type_str_1.toTypeStr(b) + "; they are not equal");
    }
    //We should have object types now.
    if ((typeof a == "function") || (typeof b == "function")) {
        throw new Error("Cannot merge " + to_type_str_1.toTypeStr(a) + " and " + to_type_str_1.toTypeStr(b) + "; they are not equal");
    }
    if ((a instanceof Date) || (b instanceof Date)) {
        if (!(a instanceof Date)) {
            throw new Error("Cannot merge " + to_type_str_1.toTypeStr(a) + " with Date");
        }
        if (!(b instanceof Date)) {
            throw new Error("Cannot merge Date with " + to_type_str_1.toTypeStr(b));
        }
        if (a.getTime() === b.getTime()) {
            return a;
        }
        else {
            throw new Error("Cannot merge dates; they must have the same value");
        }
    }
    if ((a instanceof Array) || (b instanceof Array)) {
        if (!(a instanceof Array)) {
            throw new Error("Cannot merge " + to_type_str_1.toTypeStr(a) + " with array");
        }
        if (!(b instanceof Array)) {
            throw new Error("Cannot merge array with " + to_type_str_1.toTypeStr(b));
        }
        if (a.length != b.length) {
            throw new Error("Cannot merge arrays of different lengths");
        }
        var newArray = [];
        for (var i = 0; i < a.length; ++i) {
            newArray.push(deepMergeImpl(a[i], b[i]));
        }
        return newArray;
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    var mergedKeys = {};
    var result = {};
    for (var _i = 0, aKeys_1 = aKeys; _i < aKeys_1.length; _i++) {
        var key = aKeys_1[_i];
        //We can skip a.hasOwnProperty() because Object.keys() ignores parent prototype
        if (mergedKeys[key] === true) {
            continue;
        }
        mergedKeys[key] = true;
        //We do not call `b.hasOwnProperty()` directly
        //because if `b = Object.create(null)`,
        //an `Error` will be thrown
        if (Object.prototype.hasOwnProperty.call(b, key)) {
            result[key] = deepMergeImpl(a[key], b[key]);
        }
        else {
            result[key] = a[key];
        }
    }
    for (var _a = 0, bKeys_1 = bKeys; _a < bKeys_1.length; _a++) {
        var key = bKeys_1[_a];
        //We can skip b.hasOwnProperty() because Object.keys() ignores parent prototype
        if (mergedKeys[key] === true) {
            continue;
        }
        mergedKeys[key] = true;
        //We do not call `a.hasOwnProperty()` directly
        //because if `a = Object.create(null)`,
        //an `Error` will be thrown
        if (Object.prototype.hasOwnProperty.call(a, key)) {
            result[key] = deepMergeImpl(a[key], b[key]);
        }
        else {
            result[key] = b[key];
        }
    }
    return result;
}
function deepMerge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length == 0) {
        throw new Error("Cannot deep merge zero arguments");
    }
    var result = args[0];
    for (var i = 1; i < args.length; ++i) {
        result = deepMergeImpl(result, args[i]);
    }
    return result;
}
exports.deepMerge = deepMerge;
//# sourceMappingURL=deep-merge.js.map