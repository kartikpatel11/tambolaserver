declare global {
    interface Math {
        clz32(x: number): number;
        imul(a: number, b: number): number;
    }
    interface Object {
        appendChain(oChain: any, oProto: any): void;
        setPrototypeOf(o: any, proto: object | null): any;
    }
}
/**
 * https://github.com/GoogleChromeLabs/jsbi
 */
export declare class JSBI extends Array<number> {
    private static readonly __kMaxLength;
    private static readonly __kMaxLengthBits;
    private static readonly __kMaxBitsPerChar;
    private static readonly __kBitsPerCharTableShift;
    private static readonly __kBitsPerCharTableMultiplier;
    private static readonly __kConversionChars;
    private static readonly __kBitConversionBuffer;
    private static readonly __kBitConversionDouble;
    private static readonly __kBitConversionInts;
    private sign;
    constructor(length: number, sign: boolean);
    static BigInt(arg: number | string | boolean | JSBI): JSBI;
    toDebugString(): string;
    toString(radix?: number): string;
    static toNumber(x: JSBI): number;
    static unaryMinus(x: JSBI): JSBI;
    static bitwiseNot(x: JSBI): JSBI;
    static exponentiate(x: JSBI, y: JSBI): JSBI;
    static multiply(x: JSBI, y: JSBI): JSBI;
    static divide(x: JSBI, y: JSBI): JSBI;
    static remainder(x: JSBI, y: JSBI): JSBI;
    static add(x: JSBI, y: JSBI): JSBI;
    static subtract(x: JSBI, y: JSBI): JSBI;
    static leftShift(x: JSBI, y: JSBI): JSBI;
    static signedRightShift(x: JSBI, y: JSBI): JSBI;
    static unsignedRightShift(): void;
    static lessThan(x: JSBI, y: JSBI): boolean;
    static lessThanOrEqual(x: JSBI, y: JSBI): boolean;
    static greaterThan(x: JSBI, y: JSBI): boolean;
    static greaterThanOrEqual(x: JSBI, y: JSBI): boolean;
    static equal(x: JSBI, y: JSBI): boolean;
    static notEqual(x: JSBI, y: JSBI): boolean;
    static bitwiseAnd(x: JSBI, y: JSBI): JSBI;
    static bitwiseXor(x: JSBI, y: JSBI): JSBI;
    static bitwiseOr(x: JSBI, y: JSBI): JSBI;
    static asIntN(n: number, x: JSBI): JSBI;
    static asUintN(n: number, x: JSBI): JSBI;
    static ADD(x: JSBI | string | number, y: JSBI | string | number): string | number | JSBI;
    static LT(x: JSBI, y: JSBI): boolean;
    static LE(x: JSBI, y: JSBI): boolean;
    static GT(x: JSBI, y: JSBI): boolean;
    static GE(x: JSBI, y: JSBI): boolean;
    static EQ(x: JSBI | null, y: JSBI): boolean;
    static NE(x: JSBI, y: JSBI): boolean;
    static __zero(): JSBI;
    static __oneDigit(value: number, sign: boolean): JSBI;
    __copy(): JSBI;
    __trim(): JSBI;
    __initializeDigits(): void;
    static __decideRounding(x: JSBI, mantissaBitsUnset: number, digitIndex: number, currentDigit: number): number;
    static __fromDouble(value: number): JSBI;
    static __isWhitespace(c: number): boolean;
    static __fromString(string: string, radix?: number): JSBI | null;
    static __fillFromParts(result: JSBI, parts: number[], partsBits: number[]): void;
    static __toStringBasePowerOfTwo(x: JSBI, radix: number): string;
    static __toStringGeneric(x: JSBI, radix: number, isRecursiveCall: boolean): string;
    static __unequalSign(leftNegative: boolean): number;
    static __absoluteGreater(bothNegative: boolean): number;
    static __absoluteLess(bothNegative: boolean): number;
    static __compareToBigInt(x: JSBI, y: JSBI): number;
    static __compareToNumber(x: JSBI, y: number): number;
    /**
     * @returns NaN|-1|1|0
     *
     * + NaN    : `y` was `NaN`
     * + -1     : `x < y`
     * + +1     : `x > y`
     * +  0     : `x == y`
     */
    static __compareToDouble(x: JSBI, y: number): number;
    static __equalToNumber(x: JSBI, y: number): boolean;
    static __comparisonResultToBool(result: number, op: 0 | 1 | 2 | 3): boolean;
    static __compare(x: number | string | JSBI | null, y: number | string | JSBI | null, op: 0 | 1 | 2 | 3): boolean;
    __clzmsd(): number;
    static __absoluteAdd(x: JSBI, y: JSBI, resultSign: boolean): JSBI;
    static __absoluteSub(x: JSBI, y: JSBI, resultSign: boolean): JSBI;
    static __absoluteAddOne(x: JSBI, sign: boolean, result?: JSBI | null): JSBI;
    static __absoluteSubOne(x: JSBI, resultLength?: number): JSBI;
    static __absoluteAnd(x: JSBI, y: JSBI, result?: JSBI | null): JSBI;
    static __absoluteAndNot(x: JSBI, y: JSBI, result?: JSBI | null): JSBI;
    static __absoluteOr(x: JSBI, y: JSBI, result?: JSBI | null): JSBI;
    static __absoluteXor(x: JSBI, y: JSBI, result?: JSBI | null): JSBI;
    static __absoluteCompare(x: JSBI, y: JSBI): number;
    static __multiplyAccumulate(multiplicand: JSBI, multiplier: number, accumulator: JSBI, accumulatorIndex: number): void;
    static __internalMultiplyAdd(source: JSBI, factor: number, summand: number, n: number, result: JSBI): void;
    __inplaceMultiplyAdd(multiplier: number, summand: number, length: number): void;
    static __absoluteDivSmall(x: JSBI, divisor: number, quotient: JSBI | null): JSBI;
    static __absoluteModSmall(x: JSBI, divisor: number): number;
    static __absoluteDivLarge(dividend: JSBI, divisor: JSBI, wantQuotient: true, wantRemainder: true): {
        quotient: JSBI;
        remainder: JSBI;
    };
    static __absoluteDivLarge(dividend: JSBI, divisor: JSBI, wantQuotient: true, wantRemainder: false): JSBI;
    static __absoluteDivLarge(dividend: JSBI, divisor: JSBI, wantQuotient: false, wantRemainder: true): JSBI;
    static __clz16(value: number): number;
    __inplaceAdd(summand: JSBI, startIndex: number, halfDigits: number): number;
    __inplaceSub(subtrahend: JSBI, startIndex: number, halfDigits: number): number;
    __inplaceRightShift(shift: number): void;
    static __specialLeftShift(x: JSBI, shift: number, addDigit: number): JSBI;
    static __leftShiftByAbsolute(x: JSBI, y: JSBI): JSBI;
    static __rightShiftByAbsolute(x: JSBI, y: JSBI): JSBI;
    static __rightShiftByMaximum(sign: boolean): JSBI;
    static __toShiftAmount(x: JSBI): number;
    static __toPrimitive(obj: any, hint?: string): any;
    static __toNumeric(value: string | number | JSBI): number | JSBI;
    static __isBigInt(value: any): value is JSBI;
    static __truncateToNBits(n: number, x: JSBI): JSBI;
    static __truncateAndSubFromPowerOfTwo(n: number, x: JSBI, resultSign: boolean): JSBI;
    __digit(i: number): number;
    __unsignedDigit(i: number): number;
    __setDigit(i: number, digit: number): void;
    __setDigitGrow(i: number, digit: number): void;
    __halfDigitLength(): number;
    __halfDigit(i: number): number;
    __setHalfDigit(i: number, value: number): void;
    static __digitPow(base: number, exponent: number): number;
}
//# sourceMappingURL=jsbi.d.ts.map