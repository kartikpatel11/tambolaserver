"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = require("../../type-util");
var operator_1 = require("../operator");
var array_like_1 = require("../array-like");
var string_util_1 = require("../../string-util");
var error_util_1 = require("../../error-util");
function string() {
    return function (name, mixed) {
        if (typeof mixed != "string") {
            throw error_util_1.makeMappingError({
                message: name + " must be string; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "string",
            });
        }
        return mixed;
    };
}
exports.string = string;
/**
    Calls `JSON.parse()` once.
*/
function jsonObjectString() {
    return operator_1.pipe(string(), function (name, str) {
        if (!/^\s*\{/.test(str)) {
            throw error_util_1.makeMappingError({
                message: name + " must be JSON Object string",
                inputName: name,
                actualValue: str,
                expected: "JSON Object string",
            });
        }
        try {
            JSON.parse(str);
        }
        catch (err) {
            throw error_util_1.makeMappingError({
                message: name + " must be valid JSON Object string; " + err.message,
                inputName: name,
                actualValue: str,
                expected: "valid JSON Object string",
            });
        }
        return str;
    });
}
exports.jsonObjectString = jsonObjectString;
function stringLength(args) {
    return operator_1.pipe(string(), array_like_1.length(args));
}
exports.stringLength = stringLength;
function stringExactLength(length) {
    return stringLength({
        min: length,
        max: length,
    });
}
exports.stringExactLength = stringExactLength;
function match(regex, errorDelegate) {
    return operator_1.pipe(string(), function (name, mixed) {
        if (regex.test(mixed)) {
            return mixed;
        }
        else {
            if (errorDelegate == undefined) {
                throw error_util_1.makeMappingError({
                    message: name + " must match " + regex.toString(),
                    inputName: name,
                    actualValue: mixed,
                    expected: regex.toString(),
                });
            }
            else {
                var errResult = errorDelegate(name);
                if (typeof errResult == "string") {
                    throw error_util_1.makeMappingError({
                        message: errResult,
                        inputName: name,
                        actualValue: mixed,
                        expected: regex.toString(),
                    });
                }
                else {
                    throw error_util_1.makeMappingError({
                        message: errResult.message,
                        inputName: name,
                        actualValue: mixed,
                        expected: errResult.expected,
                    });
                }
            }
        }
    });
}
exports.match = match;
function notMatch(regex, errorDelegate) {
    return operator_1.pipe(string(), function (name, mixed) {
        if (regex.test(mixed)) {
            if (errorDelegate == undefined) {
                throw error_util_1.makeMappingError({
                    message: name + " must not match " + regex.toString(),
                    inputName: name,
                    actualValue: mixed,
                    expected: "not " + regex.toString(),
                });
            }
            else {
                var errResult = errorDelegate(name);
                if (typeof errResult == "string") {
                    throw error_util_1.makeMappingError({
                        message: errResult,
                        inputName: name,
                        actualValue: mixed,
                        expected: "not " + regex.toString(),
                    });
                }
                else {
                    throw error_util_1.makeMappingError({
                        message: errResult.message,
                        inputName: name,
                        actualValue: mixed,
                        expected: errResult.expected,
                    });
                }
            }
        }
        else {
            return mixed;
        }
    });
}
exports.notMatch = notMatch;
/**
 *
 * Alias for `emailAddress()`
 *  @see {@link emailAddress}
 *
 * @deprecated
 */
function email() {
    return emailAddress();
}
exports.email = email;
/**
 * Runs the regex `/^.+@.+$/` on the string.
 * Doesn't exactly follow a standard.
 *
 * You may roll your own email address validator,
 * but it's better to just send a confirmation
 * email to check the email address is valid.
 */
function emailAddress() {
    return match(/^.+@.+$/, function (name) {
        return {
            message: name + " must be an email address",
            expected: "email address",
        };
    });
}
exports.emailAddress = emailAddress;
/**
 * + Allows empty string.
 * + Allows digits 0-9.
 * + Allows uppercase A-F.
 * + Allows lowercase a-f.
 */
function hexadecimalString() {
    return match(/^[a-fA-F0-9]*$/, function (name) {
        return {
            message: name + " must be a hexadecimal string",
            expected: "hexadecimal string",
        };
    });
}
exports.hexadecimalString = hexadecimalString;
function toUpperCase() {
    return operator_1.pipe(string(), function (_name, str) {
        return str.toUpperCase();
    });
}
exports.toUpperCase = toUpperCase;
function toLowerCase() {
    return operator_1.pipe(string(), function (_name, str) {
        return str.toLowerCase();
    });
}
exports.toLowerCase = toLowerCase;
//The `char` must be a single character or an error is thrown
function padLeft(minLength, char) {
    if (char.length != 1) {
        throw new Error("\"char\" must be one character; received " + char);
    }
    return operator_1.pipe(string(), function (_name, str) {
        if (str.length >= minLength) {
            return str;
        }
        return string_util_1.stringRepeat(char, minLength - str.length) + str;
    });
}
exports.padLeft = padLeft;
//The `char` must be a single character or an error is thrown
function padRight(minLength, char) {
    if (char.length != 1) {
        throw new Error("\"char\" must be one character; received " + char);
    }
    return operator_1.pipe(string(), function (_name, str) {
        if (str.length >= minLength) {
            return str;
        }
        return str + string_util_1.stringRepeat(char, minLength - str.length);
    });
}
exports.padRight = padRight;
function subStringBlacklist(blacklist, configuration) {
    if (configuration === void 0) { configuration = {}; }
    //We do not mind === here.
    var caseInsensitive = (configuration.caseInsensitive === true);
    if (caseInsensitive) {
        blacklist = blacklist.map(function (subString) { return subString.toLowerCase(); });
    }
    var blacklistStr = blacklist.map(function (s) { return type_util_1.toLiteralStr(s); }).join(", ");
    var expected = "not " + blacklistStr;
    return operator_1.pipe(string(), function (name, original) {
        var str = caseInsensitive ?
            original.toLowerCase() :
            original;
        var found = [];
        for (var _i = 0, blacklist_1 = blacklist; _i < blacklist_1.length; _i++) {
            var subString = blacklist_1[_i];
            if (str.indexOf(subString) >= 0) {
                found.push(subString);
            }
        }
        if (found.length == 0) {
            return original;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must not contain the following: " + blacklistStr + "; found " + found.map(function (s) { return type_util_1.toLiteralStr(s); }).join(", "),
                inputName: name,
                actualValue: original,
                expected: expected,
            });
        }
    });
}
exports.subStringBlacklist = subStringBlacklist;
function toTrimmed() {
    return operator_1.pipe(string(), function (_name, str) {
        return str.trim();
    });
}
exports.toTrimmed = toTrimmed;
//# sourceMappingURL=string.js.map