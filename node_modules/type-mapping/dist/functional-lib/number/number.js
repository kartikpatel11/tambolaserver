"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var type_util_1 = require("../../type-util");
var operator_1 = require("../operator");
var comparison_1 = require("./comparison");
var error_util_1 = require("../../error-util");
var error_code_1 = require("../../error-code");
//Unsafe because it allows NaN and +/-Infinity
function unsafeNumber() {
    return function (name, mixed) {
        if (typeof mixed != "number") {
            throw error_util_1.makeMappingError({
                message: name + " must be number; received " + type_util_1.toTypeStr(mixed),
                inputName: name,
                actualValue: mixed,
                expected: "number",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        return mixed;
    };
}
exports.unsafeNumber = unsafeNumber;
function finiteNumber() {
    return operator_1.pipe(unsafeNumber(), function (name, num) {
        if (isNaN(num)) {
            throw error_util_1.makeMappingError({
                message: name + " must be finite number; received NaN",
                inputName: name,
                actualValue: num,
                expected: "finite number",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        if (!isFinite(num)) {
            throw error_util_1.makeMappingError({
                message: name + " must be finite number; received " + num,
                inputName: name,
                actualValue: num,
                expected: "finite number",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        return num;
    });
}
exports.finiteNumber = finiteNumber;
function integer() {
    return operator_1.pipe(finiteNumber(), function (name, num) {
        if (Math.floor(num) !== num) {
            throw error_util_1.makeMappingError({
                message: name + " must be integer; received double",
                inputName: name,
                actualValue: num,
                expected: "integer",
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_TYPE,
                },
            });
        }
        return num;
    });
}
exports.integer = integer;
/**
    An unsigned integer is an integer >= 0
*/
function unsignedInteger() {
    return operator_1.pipe(integer(), comparison_1.gtEq(0));
}
exports.unsignedInteger = unsignedInteger;
//# sourceMappingURL=number.js.map