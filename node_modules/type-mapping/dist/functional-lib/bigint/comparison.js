"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = require("../operator");
var bigint_1 = require("./bigint");
var literal_1 = require("../literal");
var type_util_1 = require("../../type-util");
var bigint_util_1 = require("../../bigint-util");
var error_util_1 = require("../../error-util");
var error_code_1 = require("../../error-code");
function bigIntGt(x) {
    return operator_1.pipe(bigint_1.bigInt(), function (name, num) {
        if (bigint_util_1.greaterThan(num, x)) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be greater than " + type_util_1.toLiteralStr(x),
                inputName: name,
                actualValue: num,
                expected: "greater than " + type_util_1.toLiteralStr(x),
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_GREATER_THAN,
                    gt: x,
                },
            });
        }
    });
}
exports.bigIntGt = bigIntGt;
function bigIntLt(x) {
    return operator_1.pipe(bigint_1.bigInt(), function (name, num) {
        if (bigint_util_1.lessThan(num, x)) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be less than " + type_util_1.toLiteralStr(x),
                inputName: name,
                actualValue: num,
                expected: "less than " + type_util_1.toLiteralStr(x),
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_LESS_THAN,
                    lt: x,
                },
            });
        }
    });
}
exports.bigIntLt = bigIntLt;
function bigIntGtEq(x) {
    return operator_1.pipe(bigint_1.bigInt(), function (name, num) {
        if (bigint_util_1.greaterThanOrEqual(num, x)) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be greater than, or equal to " + type_util_1.toLiteralStr(x),
                inputName: name,
                actualValue: num,
                expected: "greater than, or equal to " + type_util_1.toLiteralStr(x),
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_GREATER_THAN_OR_EQUAL_TO,
                    gtEq: x,
                },
            });
        }
    });
}
exports.bigIntGtEq = bigIntGtEq;
function bigIntLtEq(x) {
    return operator_1.pipe(bigint_1.bigInt(), function (name, num) {
        if (bigint_util_1.lessThanOrEqual(num, x)) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be less than, or equal to " + type_util_1.toLiteralStr(x),
                inputName: name,
                actualValue: num,
                expected: "less than, or equal to " + type_util_1.toLiteralStr(x),
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_LESS_THAN_OR_EQUAL_TO,
                    ltEq: x,
                },
            });
        }
    });
}
exports.bigIntLtEq = bigIntLtEq;
function bigIntRange(args) {
    var min = ((type_util_1.isBigInt(args.gt)) ?
        ((type_util_1.isBigInt(args.gtEq)) ?
            ((bigint_util_1.greaterThanOrEqual(args.gt, args.gtEq)) ?
                {
                    f: bigIntGt(args.gt),
                    inclusive: false,
                    value: args.gt,
                } :
                {
                    f: bigIntGtEq(args.gtEq),
                    inclusive: true,
                    value: args.gtEq,
                }) :
            {
                f: bigIntGt(args.gt),
                inclusive: false,
                value: args.gt,
            }) :
        ((type_util_1.isBigInt(args.gtEq)) ?
            {
                f: bigIntGtEq(args.gtEq),
                inclusive: true,
                value: args.gtEq,
            } :
            undefined));
    var max = ((type_util_1.isBigInt(args.lt)) ?
        ((type_util_1.isBigInt(args.ltEq)) ?
            ((bigint_util_1.lessThanOrEqual(args.lt, args.ltEq)) ?
                {
                    f: bigIntLt(args.lt),
                    inclusive: false,
                    value: args.lt,
                } :
                {
                    f: bigIntLtEq(args.ltEq),
                    inclusive: true,
                    value: args.ltEq,
                }) :
            {
                f: bigIntLt(args.lt),
                inclusive: false,
                value: args.lt,
            }) :
        ((type_util_1.isBigInt(args.ltEq)) ?
            {
                f: bigIntLtEq(args.ltEq),
                inclusive: true,
                value: args.ltEq,
            } :
            undefined));
    if (min == undefined) {
        if (max == undefined) {
            return bigint_1.bigInt();
        }
        else {
            return max.f;
        }
    }
    else {
        if (max == undefined) {
            return min.f;
        }
        else {
            if (bigint_util_1.greaterThan(min.value, max.value)) {
                throw new Error("Min value cannot be greater than max value");
            }
            else if (bigint_util_1.equal(min.value, max.value)) {
                if (min.inclusive && max.inclusive) {
                    return literal_1.literal(min.value);
                }
                else {
                    throw new Error("Min value cannot be equal to max value unless using gtEq and ltEq");
                }
            }
            else {
                if (bigint_util_1.addOneImpl(min.value.toString()) == max.value.toString() &&
                    !min.inclusive &&
                    !max.inclusive) {
                    throw new Error("There is no bigint 'x' where: " + min.value.toString() + " < x < " + max.value.toString());
                }
                return operator_1.pipe(min.f, max.f);
            }
        }
    }
}
exports.bigIntRange = bigIntRange;
//# sourceMappingURL=comparison.js.map