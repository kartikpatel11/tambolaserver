"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = require("../operator");
var number_1 = require("./number");
var literal_1 = require("../literal");
var error_util_1 = require("../../error-util");
var error_code_1 = require("../../error-code");
function gt(x) {
    return operator_1.pipe(number_1.finiteNumber(), function (name, num) {
        if (num > x) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be greater than " + x,
                inputName: name,
                actualValue: num,
                expected: "greater than " + x,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_GREATER_THAN,
                    gt: x,
                },
            });
        }
    });
}
exports.gt = gt;
function lt(x) {
    return operator_1.pipe(number_1.finiteNumber(), function (name, num) {
        if (num < x) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be less than " + x,
                inputName: name,
                actualValue: num,
                expected: "less than " + x,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_LESS_THAN,
                    lt: x,
                },
            });
        }
    });
}
exports.lt = lt;
function gtEq(x) {
    return operator_1.pipe(number_1.finiteNumber(), function (name, num) {
        if (num >= x) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be greater than, or equal to " + x,
                inputName: name,
                actualValue: num,
                expected: "greater than, or equal to " + x,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_GREATER_THAN_OR_EQUAL_TO,
                    gtEq: x,
                },
            });
        }
    });
}
exports.gtEq = gtEq;
function ltEq(x) {
    return operator_1.pipe(number_1.finiteNumber(), function (name, num) {
        if (num <= x) {
            return num;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be less than, or equal to " + x,
                inputName: name,
                actualValue: num,
                expected: "less than, or equal to " + x,
                expectedMeta: {
                    errorCode: error_code_1.ErrorCode.EXPECTED_LESS_THAN_OR_EQUAL_TO,
                    ltEq: x,
                },
            });
        }
    });
}
exports.ltEq = ltEq;
function range(args) {
    var min = ((typeof args.gt == "number") ?
        ((typeof args.gtEq == "number") ?
            ((args.gt >= args.gtEq) ?
                {
                    f: gt(args.gt),
                    inclusive: false,
                    value: args.gt,
                } :
                {
                    f: gtEq(args.gtEq),
                    inclusive: true,
                    value: args.gtEq,
                }) :
            {
                f: gt(args.gt),
                inclusive: false,
                value: args.gt,
            }) :
        ((typeof args.gtEq == "number") ?
            {
                f: gtEq(args.gtEq),
                inclusive: true,
                value: args.gtEq,
            } :
            undefined));
    var max = ((typeof args.lt == "number") ?
        ((typeof args.ltEq == "number") ?
            ((args.lt <= args.ltEq) ?
                {
                    f: lt(args.lt),
                    inclusive: false,
                    value: args.lt,
                } :
                {
                    f: ltEq(args.ltEq),
                    inclusive: true,
                    value: args.ltEq,
                }) :
            {
                f: lt(args.lt),
                inclusive: false,
                value: args.lt,
            }) :
        ((typeof args.ltEq == "number") ?
            {
                f: ltEq(args.ltEq),
                inclusive: true,
                value: args.ltEq,
            } :
            undefined));
    if (min == undefined) {
        if (max == undefined) {
            return number_1.finiteNumber();
        }
        else {
            return max.f;
        }
    }
    else {
        if (max == undefined) {
            return min.f;
        }
        else {
            if (min.value > max.value) {
                throw new Error("Min value cannot be greater than max value");
            }
            else if (min.value == max.value) {
                if (min.inclusive && max.inclusive) {
                    return literal_1.literal(min.value);
                }
                else {
                    throw new Error("Min value cannot be equal to max value unless using gtEq and ltEq");
                }
            }
            else {
                return operator_1.pipe(min.f, max.f);
            }
        }
    }
}
exports.range = range;
//# sourceMappingURL=comparison.js.map