"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var enum_util_1 = require("../../enum-util");
var operator_1 = require("../operator");
var mapper_1 = require("../../mapper");
var literal_1 = require("../literal");
var type_util_1 = require("../../type-util");
var error_util_1 = require("../../error-util");
var error_code_1 = require("../../error-code");
function toEnumValue(e) {
    var entries = enum_util_1.getEntries(e);
    var expected = entries.map(function (e) { return type_util_1.toLiteralStr(e.key); }).join("|");
    //https://github.com/microsoft/TypeScript/issues/31602
    //Discovered string and conditional types also give problems
    return mapper_1.mapper(operator_1.or(literal_1.unsafeLiteral.apply(void 0, entries.map(function (e) { return e.value; })), 
    //Not a value, so maybe a key?
    function (name, mixed) {
        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var entry = entries_1[_i];
            if (mixed === entry.key) {
                return entry.value;
            }
        }
        throw error_util_1.makeMappingError({
            message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: expected,
            expectedMeta: {
                errorCode: error_code_1.ErrorCode.EXPECTED_ENUM_KEY,
                mappableValues: entries.map(function (entry) { return entry.key; }),
                outputValues: entries.map(function (entry) { return entry.value; }),
                entries: entries.slice(),
            },
        });
    }));
}
exports.toEnumValue = toEnumValue;
function toEnumKey(e) {
    var entries = enum_util_1.getEntries(e);
    var expected = entries.map(function (e) { return type_util_1.toLiteralStr(e.value); }).join("|");
    //https://github.com/microsoft/TypeScript/issues/31602
    //Discovered string and conditional types also give problems
    return mapper_1.mapper(operator_1.or(literal_1.unsafeLiteral.apply(void 0, entries.map(function (e) { return e.key; })), 
    //Not a key, so maybe a value?
    function (name, mixed) {
        for (var _i = 0, entries_2 = entries; _i < entries_2.length; _i++) {
            var entry = entries_2[_i];
            if (mixed === entry.value) {
                return entry.key;
            }
        }
        throw error_util_1.makeMappingError({
            message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: expected,
            expectedMeta: {
                errorCode: error_code_1.ErrorCode.EXPECTED_ENUM_VALUE,
                mappableValues: entries.map(function (entry) { return entry.value; }),
                outputValues: entries.map(function (entry) { return entry.key; }),
                entries: entries.slice(),
            },
        });
    }));
}
exports.toEnumKey = toEnumKey;
function toOneEnumValue(e, k) {
    var desiredValue = e[k];
    var entries = enum_util_1.getEntries(e);
    var validKeys = entries
        .filter(function (entry) { return (entry.value === desiredValue &&
        entry.key !== desiredValue); })
        .map(function (entry) { return entry.key; });
    var expected = (type_util_1.toLiteralOrTypeUnionStr([
        desiredValue
    ].concat(validKeys)));
    return mapper_1.mapper(function (name, mixed) {
        if (mixed === desiredValue) {
            return desiredValue;
        }
        for (var _i = 0, validKeys_1 = validKeys; _i < validKeys_1.length; _i++) {
            var validKey = validKeys_1[_i];
            if (mixed === validKey) {
                return desiredValue;
            }
        }
        throw error_util_1.makeMappingError({
            message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: expected,
            expectedMeta: {
                errorCode: error_code_1.ErrorCode.EXPECTED_ONE_ENUM_VALUE_OR_VALID_ENUM_KEY,
                mappableValues: [desiredValue].concat(validKeys),
                outputValues: [desiredValue],
                desiredValue: desiredValue,
                validKeys: validKeys.slice(),
            },
        });
    });
}
exports.toOneEnumValue = toOneEnumValue;
function toOneEnumKey(e, k) {
    var validValue = e[k];
    var entries = enum_util_1.getEntries(e);
    var validKeys = entries
        .filter(function (e) { return (e.value === validValue &&
        e.key !== validValue &&
        e.key !== k); })
        .map(function (e) { return e.key; });
    var expected = (type_util_1.toLiteralOrTypeUnionStr([
        k
    ].concat(validKeys, [
        validValue,
    ])));
    return mapper_1.mapper(function (name, mixed) {
        if (mixed === k) {
            return k;
        }
        for (var _i = 0, validKeys_2 = validKeys; _i < validKeys_2.length; _i++) {
            var validKey = validKeys_2[_i];
            if (mixed === validKey) {
                return k;
            }
        }
        if (mixed === validValue) {
            return k;
        }
        throw error_util_1.makeMappingError({
            message: name + " must be " + expected + "; received " + type_util_1.toTypeStr(mixed),
            inputName: name,
            actualValue: mixed,
            expected: expected,
            expectedMeta: {
                mappableValues: [k].concat(validKeys, [validValue]),
                outputValues: [k],
                desiredKey: k,
                validKeys: validKeys.slice(),
                validValue: validValue,
            },
        });
    });
}
exports.toOneEnumKey = toOneEnumKey;
//# sourceMappingURL=cast.js.map