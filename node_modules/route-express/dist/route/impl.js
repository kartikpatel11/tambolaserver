"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var tm = require("type-mapping");
var rd = require("route-declaration");
var express = require("express");
var handler = require("../handler-lib");
var void_handler_1 = require("../void-handler");
var value_handler_1 = require("../value-handler");
var async_void_handler_1 = require("../async-void-handler");
var async_value_handler_1 = require("../async-value-handler");
var input_mapping_error_1 = require("../input-mapping-error");
function getRouterHandler(route, method) {
    switch (method) {
        case "GET": {
            return route.get.bind(route);
        }
        case "POST": {
            return route.post.bind(route);
        }
        case "PUT": {
            return route.put.bind(route);
        }
        case "DELETE": {
            return route.delete.bind(route);
        }
        case "PATCH": {
            return route.patch.bind(route);
        }
        case "HEAD": {
            return route.head.bind(route);
        }
        case "OPTIONS": {
            return route.options.bind(route);
        }
        case "CONNECT": {
            //The .d.ts file is wrong.
            //This exists.
            return route.connect.bind(route);
        }
        default: {
            throw new Error("Method " + method + " not supported");
        }
    }
}
var Route = /** @class */ (function () {
    function Route(args) {
        var method = rd.RouteUtil.getMethod(args.routeDeclaration);
        var fullName = method + " " + args.routeDeclaration.path.routerPath;
        var expressRoute = args.expressRouter.route(args.routeDeclaration.path.routerPath);
        this.expressRouterHandler = getRouterHandler(expressRoute, method);
        /*
            These handlers will invoke the mappers of the
            route declaration before running any other handlers.

            Every time we call `this.routerHandler()`,
            the state of the `expressRoute` object changes.
        */
        this.expressRouterHandler.apply(this, [(function (req, res, next) {
                if (res.headersSent) {
                    console.warn("Headers already sent for: " + req.method + " " + req.path + ". Skipping route handlers for: " + fullName);
                    return;
                }
                else {
                    next();
                }
            })].concat(args.preRouteHandlers, [
            /*
                We do not permit any error handlers in `IRoute<>`
                because we don't want any handlers catching a validation/mapping error.
            */
            //We want to parse JSON body, if it hasn't already been parsed
            express.json(),
            handler.responseMapper(args.routeDeclaration),
            function (req, _res, next) {
                var rawHeaderMapper = args.routeDeclaration.header;
                var paramMapper = (args.routeDeclaration.param == undefined) ?
                    function () { return ({}); } :
                    args.routeDeclaration.param;
                var queryMapper = (args.routeDeclaration.query == undefined) ?
                    function () { return ({}); } :
                    args.routeDeclaration.query;
                var bodyMapper = (args.routeDeclaration.body == undefined) ?
                    function () { return ({}); } :
                    args.routeDeclaration.body;
                var headerMapper = (rawHeaderMapper == undefined) ?
                    function (_name, mixed) {
                        return mixed;
                    } :
                    function (name, mixed) {
                        //Note that header keys become lowercase.
                        //`Api-Key` becomes `api-key`.
                        //`ApiKey` becomes `apikey`.
                        //You might want a `rename<>()` mapper.
                        //`rename("api-key", "apiKey", f)`
                        var clean = rawHeaderMapper(name, mixed);
                        //When running the assertion,
                        //fields not checked are removed.
                        //But we want the unchecked headers
                        //to remain; they'll just be strings
                        return __assign({}, mixed, clean);
                    };
                var paramResult = tm.tryMapHandled(paramMapper, "parameter", req.params);
                var queryResult = tm.tryMapHandled(queryMapper, "query", req.query);
                var bodyResult = tm.tryMapHandled(bodyMapper, "body", req.body);
                var headerResult = tm.tryMapHandled(headerMapper, "header", req.headers);
                if (paramResult.success &&
                    queryResult.success &&
                    bodyResult.success &&
                    headerResult.success) {
                    req.params = paramResult.value;
                    req.query = queryResult.value;
                    req.body = bodyResult.value;
                    req.headers = headerResult.value;
                    next();
                    return;
                }
                next(input_mapping_error_1.makeInputMappingError({
                    message: "One or more errors were found with input",
                    routeDeclaration: args.routeDeclaration,
                    param: (paramResult.success ?
                        undefined :
                        paramResult.mappingError),
                    query: (queryResult.success ?
                        undefined :
                        queryResult.mappingError),
                    body: (bodyResult.success ?
                        undefined :
                        bodyResult.mappingError),
                    header: (headerResult.success ?
                        undefined :
                        headerResult.mappingError),
                }));
            }]));
    }
    Route.prototype.voidHandler = function (handler) {
        this.expressRouterHandler(void_handler_1.VoidHandlerUtil.toSafeRequestVoidHandler(handler));
        return this;
    };
    Route.prototype.valueHandler = function (handler) {
        this.expressRouterHandler(value_handler_1.ValueHandlerUtil.toSafeRequestVoidHandler(handler));
        return this;
    };
    Route.prototype.asyncVoidHandler = function (handler) {
        this.expressRouterHandler(async_void_handler_1.AsyncVoidHandlerUtil.toSafeRequestVoidHandler(handler));
        return this;
    };
    Route.prototype.asyncValueHandler = function (handler) {
        this.expressRouterHandler(async_value_handler_1.AsyncValueHandlerUtil.toSafeRequestVoidHandler(handler));
        return this;
    };
    return Route;
}());
function route(routeDeclaration, expressRouter, preRouteHandlers) {
    return new Route({
        routeDeclaration: routeDeclaration,
        expressRouter: expressRouter,
        preRouteHandlers: preRouteHandlers,
    });
}
exports.route = route;
/*
function getRouterMatcher (
    router : expressCore.IRouter,
    method : Exclude<rd.MethodStr, "Contextual">
) : expressCore.IRouterMatcher<expressCore.IRouter> {
    switch (method) {
        case "GET": {
            return router.get.bind(router);
        }
        case "POST": {
            return router.post.bind(router);
        }
        case "PUT": {
            return router.put.bind(router);
        }
        case "DELETE": {
            return router.delete.bind(router);
        }
        case "PATCH": {
            return router.patch.bind(router);
        }
        case "HEAD": {
            return router.head.bind(router);
        }
        case "OPTIONS": {
            return router.options.bind(router);
        }
        case "CONNECT": {
            return router.connect.bind(router);
        }
        default: {
            throw new Error(`Method ${method} not supported`);
        }
    }
}
*/ 
//# sourceMappingURL=impl.js.map