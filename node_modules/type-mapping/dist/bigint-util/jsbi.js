"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32#Polyfill
 */
function clz32(x) {
    // Let n be ToUint32(x).
    // Let p be the number of leading zero bits in
    // the 32-bit binary representation of n.
    // Return p.
    var asUint = x >>> 0;
    if (asUint === 0) {
        return 32;
    }
    return 31 - (Math.log(asUint) / Math.LN2 | 0) | 0; // the "| 0" acts like math.floor
}
/**
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul#Polyfill
 */
function imul(a, b) {
    var aHi = (a >>> 16) & 0xffff;
    var aLo = a & 0xffff;
    var bHi = (b >>> 16) & 0xffff;
    var bLo = b & 0xffff;
    // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value
    return ((aLo * bLo) + (((aHi * bLo + aLo * bHi) << 16) >>> 0) | 0);
}
if (Math.clz32 == undefined) {
    Math.clz32 = clz32;
}
if (Math.imul == undefined) {
    Math.imul = imul;
}
if (Symbol == undefined) {
    Symbol = {};
}
/**
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf
 */
/**
*** Object.appendChain(@object, @prototype)
*
* Appends the first non-native prototype of a chain to a new prototype.
* Returns @object (if it was a primitive value it will transformed into an object).
*
*** Object.appendChain(@object [, "@arg_name_1", "@arg_name_2", "@arg_name_3", "..."], "@function_body")
*** Object.appendChain(@object [, "@arg_name_1, @arg_name_2, @arg_name_3, ..."], "@function_body")
*
* Appends the first non-native prototype of a chain to the native Function.prototype object, then appends a
* new Function(["@arg"(s)], "@function_body") to that chain.
* Returns the function.
*
**/
Object.appendChain = function (oChain, oProto) {
    if (arguments.length < 2) {
        throw new TypeError('Object.appendChain - Not enough arguments');
    }
    if (typeof oProto !== 'object' && typeof oProto !== 'string') {
        throw new TypeError('second argument to Object.appendChain must be an object or a string');
    }
    var oNewProto = oProto;
    var oReturn = oChain instanceof this ? oChain : new oChain.constructor(oChain);
    var o2nd = oReturn;
    var oLast = oReturn;
    for (var o1st = this.getPrototypeOf(o2nd); o1st !== Object.prototype && o1st !== Function.prototype; o1st = this.getPrototypeOf(o2nd)) {
        o2nd = o1st;
    }
    if (oProto.constructor === String) {
        oNewProto = Function.prototype;
        oReturn = Function.apply(null, Array.prototype.slice.call(arguments, 1));
        this.setPrototypeOf(oReturn, oLast);
    }
    this.setPrototypeOf(o2nd, oNewProto);
    return oReturn;
};
// Copyright 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the “License”);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// <https://apache.org/licenses/LICENSE-2.0>.
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an “AS IS” BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * https://github.com/GoogleChromeLabs/jsbi
 */
var JSBI = /** @class */ (function (_super) {
    __extends(JSBI, _super);
    function JSBI(length, sign) {
        var _this = this;
        if (length > JSBI.__kMaxLength) {
            throw new RangeError('Maximum BigInt size exceeded');
        }
        _this = _super.call(this, length) || this;
        _this.sign = sign;
        Object.setPrototypeOf(_this, JSBI.prototype);
        return _this;
    }
    JSBI.BigInt = function (arg) {
        if (typeof arg === 'number') {
            if (arg === 0)
                return JSBI.__zero();
            if ((arg | 0) === arg) {
                if (arg < 0) {
                    return JSBI.__oneDigit(-arg, true);
                }
                return JSBI.__oneDigit(arg, false);
            }
            if (!isFinite(arg) || Math.floor(arg) !== arg) {
                throw new RangeError('The number ' + arg + ' cannot be converted to ' +
                    'BigInt because it is not an integer');
            }
            return JSBI.__fromDouble(arg);
        }
        else if (typeof arg === 'string') {
            var result = JSBI.__fromString(arg);
            if (result === null) {
                throw new SyntaxError('Cannot convert ' + arg + ' to a BigInt');
            }
            return result;
        }
        else if (typeof arg === 'boolean') {
            if (arg === true) {
                return JSBI.__oneDigit(1, false);
            }
            return JSBI.__zero();
        }
        else if (typeof arg === 'object') {
            if (arg.constructor === JSBI)
                return arg;
            var primitive = JSBI.__toPrimitive(arg);
            return JSBI.BigInt(primitive);
        }
        throw new TypeError('Cannot convert ' + arg + ' to a BigInt');
    };
    JSBI.prototype.toDebugString = function () {
        var result = ['BigInt['];
        for (var _i = 0, _a = this; _i < _a.length; _i++) {
            var digit = _a[_i];
            result.push((digit ? (digit >>> 0).toString(16) : digit) + ', ');
        }
        result.push(']');
        return result.join('');
    };
    JSBI.prototype.toString = function (radix) {
        if (radix === void 0) { radix = 10; }
        if (radix < 2 || radix > 36) {
            throw new RangeError('toString() radix argument must be between 2 and 36');
        }
        if (this.length === 0)
            return '0';
        if ((radix & (radix - 1)) === 0) {
            return JSBI.__toStringBasePowerOfTwo(this, radix);
        }
        return JSBI.__toStringGeneric(this, radix, false);
    };
    // Equivalent of "Number(my_bigint)" in the native implementation.
    JSBI.toNumber = function (x) {
        var xLength = x.length;
        if (xLength === 0)
            return 0;
        if (xLength === 1) {
            var value = x.__unsignedDigit(0);
            return x.sign ? -value : value;
        }
        var xMsd = x.__digit(xLength - 1);
        var msdLeadingZeros = Math.clz32(xMsd);
        var xBitLength = xLength * 32 - msdLeadingZeros;
        if (xBitLength > 1024)
            return x.sign ? -Infinity : Infinity;
        var exponent = xBitLength - 1;
        var currentDigit = xMsd;
        var digitIndex = xLength - 1;
        var shift = msdLeadingZeros + 1;
        var mantissaHigh = (shift === 32) ? 0 : currentDigit << shift;
        mantissaHigh >>>= 12;
        var mantissaHighBitsUnset = shift - 12;
        var mantissaLow = (shift >= 12) ? 0 : (currentDigit << (20 + shift));
        var mantissaLowBitsUnset = 20 + shift;
        if (mantissaHighBitsUnset > 0 && digitIndex > 0) {
            digitIndex--;
            currentDigit = x.__digit(digitIndex);
            mantissaHigh |= (currentDigit >>> (32 - mantissaHighBitsUnset));
            mantissaLow = currentDigit << mantissaHighBitsUnset;
            mantissaLowBitsUnset = mantissaHighBitsUnset;
        }
        if (mantissaLowBitsUnset > 0 && digitIndex > 0) {
            digitIndex--;
            currentDigit = x.__digit(digitIndex);
            mantissaLow |= (currentDigit >>> (32 - mantissaLowBitsUnset));
            mantissaLowBitsUnset -= 32;
        }
        var rounding = JSBI.__decideRounding(x, mantissaLowBitsUnset, digitIndex, currentDigit);
        if (rounding === 1 || (rounding === 0 && (mantissaLow & 1) === 1)) {
            mantissaLow = (mantissaLow + 1) >>> 0;
            if (mantissaLow === 0) {
                // Incrementing mantissaLow overflowed.
                mantissaHigh++;
                if ((mantissaHigh >>> 20) !== 0) {
                    // Incrementing mantissaHigh overflowed.
                    mantissaHigh = 0;
                    exponent++;
                    if (exponent > 1023) {
                        // Incrementing the exponent overflowed.
                        return x.sign ? -Infinity : Infinity;
                    }
                }
            }
        }
        var signBit = x.sign ? (1 << 31) : 0;
        exponent = (exponent + 0x3FF) << 20;
        JSBI.__kBitConversionInts[1] = signBit | exponent | mantissaHigh;
        JSBI.__kBitConversionInts[0] = mantissaLow;
        return JSBI.__kBitConversionDouble[0];
    };
    // Operations.
    JSBI.unaryMinus = function (x) {
        if (x.length === 0)
            return x;
        var result = x.__copy();
        result.sign = !x.sign;
        return result;
    };
    JSBI.bitwiseNot = function (x) {
        if (x.sign) {
            // ~(-x) == ~(~(x-1)) == x-1
            return JSBI.__absoluteSubOne(x).__trim();
        }
        // ~x == -x-1 == -(x+1)
        return JSBI.__absoluteAddOne(x, true);
    };
    JSBI.exponentiate = function (x, y) {
        if (y.sign) {
            throw new RangeError('Exponent must be positive');
        }
        if (y.length === 0) {
            return JSBI.__oneDigit(1, false);
        }
        if (x.length === 0)
            return x;
        if (x.length === 1 && x.__digit(0) === 1) {
            // (-1) ** even_number == 1.
            if (x.sign && (y.__digit(0) & 1) === 0) {
                return JSBI.unaryMinus(x);
            }
            // (-1) ** odd_number == -1, 1 ** anything == 1.
            return x;
        }
        // For all bases >= 2, very large exponents would lead to unrepresentable
        // results.
        if (y.length > 1)
            throw new RangeError('BigInt too big');
        var expValue = y.__unsignedDigit(0);
        if (expValue === 1)
            return x;
        if (expValue >= JSBI.__kMaxLengthBits) {
            throw new RangeError('BigInt too big');
        }
        if (x.length === 1 && x.__digit(0) === 2) {
            // Fast path for 2^n.
            var neededDigits = 1 + (expValue >>> 5);
            var sign = x.sign && ((expValue & 1) !== 0);
            var result_1 = new JSBI(neededDigits, sign);
            result_1.__initializeDigits();
            // All bits are zero. Now set the n-th bit.
            var msd = 1 << (expValue & 31);
            result_1.__setDigit(neededDigits - 1, msd);
            return result_1;
        }
        var result = null;
        var runningSquare = x;
        // This implicitly sets the result's sign correctly.
        if ((expValue & 1) !== 0)
            result = x;
        expValue >>= 1;
        for (; expValue !== 0; expValue >>= 1) {
            runningSquare = JSBI.multiply(runningSquare, runningSquare);
            if ((expValue & 1) !== 0) {
                if (result === null) {
                    result = runningSquare;
                }
                else {
                    result = JSBI.multiply(result, runningSquare);
                }
            }
        }
        if (result == null) {
            throw new Error("Could not exponentiate");
        }
        return result;
    };
    JSBI.multiply = function (x, y) {
        if (x.length === 0)
            return x;
        if (y.length === 0)
            return y;
        var resultLength = x.length + y.length;
        if (x.__clzmsd() + y.__clzmsd() >= 32) {
            resultLength--;
        }
        var result = new JSBI(resultLength, x.sign !== y.sign);
        result.__initializeDigits();
        for (var i = 0; i < x.length; i++) {
            JSBI.__multiplyAccumulate(y, x.__digit(i), result, i);
        }
        return result.__trim();
    };
    JSBI.divide = function (x, y) {
        if (y.length === 0)
            throw new RangeError('Division by zero');
        if (JSBI.__absoluteCompare(x, y) < 0)
            return JSBI.__zero();
        var resultSign = x.sign !== y.sign;
        var divisor = y.__unsignedDigit(0);
        var quotient;
        if (y.length === 1 && divisor <= 0xFFFF) {
            if (divisor === 1) {
                return resultSign === x.sign ? x : JSBI.unaryMinus(x);
            }
            quotient = JSBI.__absoluteDivSmall(x, divisor, null);
        }
        else {
            quotient = JSBI.__absoluteDivLarge(x, y, true, false);
        }
        quotient.sign = resultSign;
        return quotient.__trim();
    };
    JSBI.remainder = function (x, y) {
        if (y.length === 0)
            throw new RangeError('Division by zero');
        if (JSBI.__absoluteCompare(x, y) < 0)
            return x;
        var divisor = y.__unsignedDigit(0);
        if (y.length === 1 && divisor <= 0xFFFF) {
            if (divisor === 1)
                return JSBI.__zero();
            var remainderDigit = JSBI.__absoluteModSmall(x, divisor);
            if (remainderDigit === 0)
                return JSBI.__zero();
            return JSBI.__oneDigit(remainderDigit, x.sign);
        }
        var remainder = JSBI.__absoluteDivLarge(x, y, false, true);
        remainder.sign = x.sign;
        return remainder.__trim();
    };
    JSBI.add = function (x, y) {
        var sign = x.sign;
        if (sign === y.sign) {
            // x + y == x + y
            // -x + -y == -(x + y)
            return JSBI.__absoluteAdd(x, y, sign);
        }
        // x + -y == x - y == -(y - x)
        // -x + y == y - x == -(x - y)
        if (JSBI.__absoluteCompare(x, y) >= 0) {
            return JSBI.__absoluteSub(x, y, sign);
        }
        return JSBI.__absoluteSub(y, x, !sign);
    };
    JSBI.subtract = function (x, y) {
        var sign = x.sign;
        if (sign !== y.sign) {
            // x - (-y) == x + y
            // (-x) - y == -(x + y)
            return JSBI.__absoluteAdd(x, y, sign);
        }
        // x - y == -(y - x)
        // (-x) - (-y) == y - x == -(x - y)
        if (JSBI.__absoluteCompare(x, y) >= 0) {
            return JSBI.__absoluteSub(x, y, sign);
        }
        return JSBI.__absoluteSub(y, x, !sign);
    };
    JSBI.leftShift = function (x, y) {
        if (y.length === 0 || x.length === 0)
            return x;
        if (y.sign)
            return JSBI.__rightShiftByAbsolute(x, y);
        return JSBI.__leftShiftByAbsolute(x, y);
    };
    JSBI.signedRightShift = function (x, y) {
        if (y.length === 0 || x.length === 0)
            return x;
        if (y.sign)
            return JSBI.__leftShiftByAbsolute(x, y);
        return JSBI.__rightShiftByAbsolute(x, y);
    };
    JSBI.unsignedRightShift = function () {
        throw new TypeError('BigInts have no unsigned right shift; use >> instead');
    };
    JSBI.lessThan = function (x, y) {
        return JSBI.__compareToBigInt(x, y) < 0;
    };
    JSBI.lessThanOrEqual = function (x, y) {
        return JSBI.__compareToBigInt(x, y) <= 0;
    };
    JSBI.greaterThan = function (x, y) {
        return JSBI.__compareToBigInt(x, y) > 0;
    };
    JSBI.greaterThanOrEqual = function (x, y) {
        return JSBI.__compareToBigInt(x, y) >= 0;
    };
    JSBI.equal = function (x, y) {
        if (x.sign !== y.sign)
            return false;
        if (x.length !== y.length)
            return false;
        for (var i = 0; i < x.length; i++) {
            if (x.__digit(i) !== y.__digit(i))
                return false;
        }
        return true;
    };
    JSBI.notEqual = function (x, y) {
        return !JSBI.equal(x, y);
    };
    JSBI.bitwiseAnd = function (x, y) {
        var _a;
        if (!x.sign && !y.sign) {
            return JSBI.__absoluteAnd(x, y).__trim();
        }
        else if (x.sign && y.sign) {
            var resultLength = Math.max(x.length, y.length) + 1;
            // (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1))
            // == -(((x-1) | (y-1)) + 1)
            var result = JSBI.__absoluteSubOne(x, resultLength);
            var y1 = JSBI.__absoluteSubOne(y);
            result = JSBI.__absoluteOr(result, y1, result);
            return JSBI.__absoluteAddOne(result, true, result).__trim();
        }
        // Assume that x is the positive BigInt.
        if (x.sign) {
            _a = [y, x], x = _a[0], y = _a[1];
        }
        // x & (-y) == x & ~(y-1) == x &~ (y-1)
        return JSBI.__absoluteAndNot(x, JSBI.__absoluteSubOne(y)).__trim();
    };
    JSBI.bitwiseXor = function (x, y) {
        var _a;
        if (!x.sign && !y.sign) {
            return JSBI.__absoluteXor(x, y).__trim();
        }
        else if (x.sign && y.sign) {
            // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)
            var resultLength_1 = Math.max(x.length, y.length);
            var result_2 = JSBI.__absoluteSubOne(x, resultLength_1);
            var y1 = JSBI.__absoluteSubOne(y);
            return JSBI.__absoluteXor(result_2, y1, result_2).__trim();
        }
        var resultLength = Math.max(x.length, y.length) + 1;
        // Assume that x is the positive BigInt.
        if (x.sign) {
            _a = [y, x], x = _a[0], y = _a[1];
        }
        // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)
        var result = JSBI.__absoluteSubOne(y, resultLength);
        result = JSBI.__absoluteXor(result, x, result);
        return JSBI.__absoluteAddOne(result, true, result).__trim();
    };
    JSBI.bitwiseOr = function (x, y) {
        var _a;
        var resultLength = Math.max(x.length, y.length);
        if (!x.sign && !y.sign) {
            return JSBI.__absoluteOr(x, y).__trim();
        }
        else if (x.sign && y.sign) {
            // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1))
            // == -(((x-1) & (y-1)) + 1)
            var result_3 = JSBI.__absoluteSubOne(x, resultLength);
            var y1 = JSBI.__absoluteSubOne(y);
            result_3 = JSBI.__absoluteAnd(result_3, y1, result_3);
            return JSBI.__absoluteAddOne(result_3, true, result_3).__trim();
        }
        // Assume that x is the positive BigInt.
        if (x.sign) {
            _a = [y, x], x = _a[0], y = _a[1];
        }
        // x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) ~& x) + 1)
        var result = JSBI.__absoluteSubOne(y, resultLength);
        result = JSBI.__absoluteAndNot(result, x, result);
        return JSBI.__absoluteAddOne(result, true, result).__trim();
    };
    JSBI.asIntN = function (n, x) {
        if (x.length === 0)
            return x;
        if (n === 0)
            return JSBI.__zero();
        // If {x} has less than {n} bits, return it directly.
        if (n >= JSBI.__kMaxLengthBits)
            return x;
        var neededLength = (n + 31) >>> 5;
        if (x.length < neededLength)
            return x;
        var topDigit = x.__unsignedDigit(neededLength - 1);
        var compareDigit = 1 << ((n - 1) & 31);
        if (x.length === neededLength && topDigit < compareDigit)
            return x;
        // Otherwise truncate and simulate two's complement.
        var hasBit = (topDigit & compareDigit) === compareDigit;
        if (!hasBit)
            return JSBI.__truncateToNBits(n, x);
        if (!x.sign)
            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, true);
        if ((topDigit & (compareDigit - 1)) === 0) {
            for (var i = neededLength - 2; i >= 0; i--) {
                if (x.__digit(i) !== 0) {
                    return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);
                }
            }
            if (x.length === neededLength && topDigit === compareDigit)
                return x;
            return JSBI.__truncateToNBits(n, x);
        }
        return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);
    };
    JSBI.asUintN = function (n, x) {
        if (x.length === 0)
            return x;
        if (n === 0)
            return JSBI.__zero();
        // If {x} is negative, simulate two's complement representation.
        if (x.sign) {
            if (n > JSBI.__kMaxLengthBits) {
                throw new RangeError('BigInt too big');
            }
            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);
        }
        // If {x} is positive and has up to {n} bits, return it directly.
        if (n >= JSBI.__kMaxLengthBits)
            return x;
        var neededLength = (n + 31) >>> 5;
        if (x.length < neededLength)
            return x;
        var bitsInTopDigit = n & 31;
        if (x.length == neededLength) {
            if (bitsInTopDigit === 0)
                return x;
            var topDigit = x.__digit(neededLength - 1);
            if ((topDigit >>> bitsInTopDigit) === 0)
                return x;
        }
        // Otherwise, truncate.
        return JSBI.__truncateToNBits(n, x);
    };
    // Operators.
    JSBI.ADD = function (x, y) {
        x = JSBI.__toPrimitive(x);
        y = JSBI.__toPrimitive(y);
        if (typeof x === 'string') {
            if (typeof y !== 'string')
                y = y.toString();
            return x + y;
        }
        if (typeof y === 'string') {
            return x.toString() + y;
        }
        x = JSBI.__toNumeric(x);
        y = JSBI.__toNumeric(y);
        if (JSBI.__isBigInt(x) && JSBI.__isBigInt(y)) {
            return JSBI.add(x, y);
        }
        if (typeof x === 'number' && typeof y === 'number') {
            return x + y;
        }
        throw new TypeError('Cannot mix BigInt and other types, use explicit conversions');
    };
    JSBI.LT = function (x, y) {
        return JSBI.__compare(x, y, 0);
    };
    JSBI.LE = function (x, y) {
        return JSBI.__compare(x, y, 1);
    };
    JSBI.GT = function (x, y) {
        return JSBI.__compare(x, y, 2);
    };
    JSBI.GE = function (x, y) {
        return JSBI.__compare(x, y, 3);
    };
    JSBI.EQ = function (x, y) {
        while (true) {
            if (JSBI.__isBigInt(x)) {
                if (JSBI.__isBigInt(y))
                    return JSBI.equal(x, y);
                return JSBI.EQ(y, x);
            }
            else if (typeof x === 'number') {
                if (JSBI.__isBigInt(y))
                    return JSBI.__equalToNumber(y, x);
                if (typeof y !== 'object')
                    return x == y;
                y = JSBI.__toPrimitive(y);
            }
            else if (typeof x === 'string') {
                if (JSBI.__isBigInt(y)) {
                    x = JSBI.__fromString(x);
                    if (x === null)
                        return false;
                    return JSBI.equal(x, y);
                }
                if (typeof y !== 'object')
                    return x == y;
                y = JSBI.__toPrimitive(y);
            }
            else if (typeof x === 'boolean') {
                if (JSBI.__isBigInt(y))
                    return JSBI.__equalToNumber(y, +x);
                if (typeof y !== 'object')
                    return x == y;
                y = JSBI.__toPrimitive(y);
            }
            else if (typeof x === 'symbol') {
                if (JSBI.__isBigInt(y))
                    return false;
                if (typeof y !== 'object')
                    return x == y;
                y = JSBI.__toPrimitive(y);
            }
            else if (typeof x === 'object') {
                if (typeof y === 'object' && y.constructor !== JSBI)
                    return x == y;
                x = JSBI.__toPrimitive(x);
            }
            else {
                return x == y;
            }
        }
    };
    JSBI.NE = function (x, y) {
        return !JSBI.EQ(x, y);
    };
    // Helpers.
    JSBI.__zero = function () {
        return new JSBI(0, false);
    };
    JSBI.__oneDigit = function (value, sign) {
        var result = new JSBI(1, sign);
        result.__setDigit(0, value);
        return result;
    };
    JSBI.prototype.__copy = function () {
        var result = new JSBI(this.length, this.sign);
        for (var i = 0; i < this.length; i++) {
            result[i] = this[i];
        }
        return result;
    };
    JSBI.prototype.__trim = function () {
        var newLength = this.length;
        var last = this[newLength - 1];
        while (last === 0) {
            newLength--;
            last = this[newLength - 1];
            this.pop();
        }
        if (newLength === 0)
            this.sign = false;
        return this;
    };
    JSBI.prototype.__initializeDigits = function () {
        for (var i = 0; i < this.length; i++) {
            this[i] = 0;
        }
    };
    JSBI.__decideRounding = function (x, mantissaBitsUnset, digitIndex, currentDigit) {
        if (mantissaBitsUnset > 0)
            return -1;
        var topUnconsumedBit;
        if (mantissaBitsUnset < 0) {
            topUnconsumedBit = -mantissaBitsUnset - 1;
        }
        else {
            // {currentDigit} fit the mantissa exactly; look at the next digit.
            if (digitIndex === 0)
                return -1;
            digitIndex--;
            currentDigit = x.__digit(digitIndex);
            topUnconsumedBit = 31;
        }
        // If the most significant remaining bit is 0, round down.
        var mask = 1 << topUnconsumedBit;
        if ((currentDigit & mask) === 0)
            return -1;
        // If any other remaining bit is set, round up.
        mask -= 1;
        if ((currentDigit & mask) !== 0)
            return 1;
        while (digitIndex > 0) {
            digitIndex--;
            if (x.__digit(digitIndex) !== 0)
                return 1;
        }
        return 0;
    };
    JSBI.__fromDouble = function (value) {
        var sign = value < 0;
        JSBI.__kBitConversionDouble[0] = value;
        var rawExponent = (JSBI.__kBitConversionInts[1] >>> 20) & 0x7FF;
        var exponent = rawExponent - 0x3FF;
        var digits = (exponent >>> 5) + 1;
        var result = new JSBI(digits, sign);
        var kHiddenBit = 0x00100000;
        var mantissaHigh = (JSBI.__kBitConversionInts[1] & 0xFFFFF) | kHiddenBit;
        var mantissaLow = JSBI.__kBitConversionInts[0];
        var kMantissaHighTopBit = 20;
        // 0-indexed position of most significant bit in most significant digit.
        var msdTopBit = exponent & 31;
        // Number of unused bits in the mantissa. We'll keep them shifted to the
        // left (i.e. most significant part).
        var remainingMantissaBits = 0;
        // Next digit under construction.
        var digit;
        // First, build the MSD by shifting the mantissa appropriately.
        if (msdTopBit < kMantissaHighTopBit) {
            var shift = kMantissaHighTopBit - msdTopBit;
            remainingMantissaBits = shift + 32;
            digit = mantissaHigh >>> shift;
            mantissaHigh = (mantissaHigh << (32 - shift)) |
                (mantissaLow >>> shift);
            mantissaLow = mantissaLow << (32 - shift);
        }
        else if (msdTopBit === kMantissaHighTopBit) {
            remainingMantissaBits = 32;
            digit = mantissaHigh;
            mantissaHigh = mantissaLow;
        }
        else {
            var shift = msdTopBit - kMantissaHighTopBit;
            remainingMantissaBits = 32 - shift;
            digit = (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));
            mantissaHigh = mantissaLow << shift;
        }
        result.__setDigit(digits - 1, digit);
        // Then fill in the rest of the digits.
        for (var digitIndex = digits - 2; digitIndex >= 0; digitIndex--) {
            if (remainingMantissaBits > 0) {
                remainingMantissaBits -= 32;
                digit = mantissaHigh;
                mantissaHigh = mantissaLow;
            }
            else {
                digit = 0;
            }
            result.__setDigit(digitIndex, digit);
        }
        return result.__trim();
    };
    JSBI.__isWhitespace = function (c) {
        if (c <= 0x0D && c >= 0x09)
            return true;
        if (c <= 0x9F)
            return c === 0x20;
        if (c <= 0x01FFFF) {
            return c === 0xA0 || c === 0x1680;
        }
        if (c <= 0x02FFFF) {
            c &= 0x01FFFF;
            return c <= 0x0A || c === 0x28 || c === 0x29 || c === 0x2F ||
                c === 0x5F || c === 0x1000;
        }
        return c === 0xFEFF;
    };
    JSBI.__fromString = function (string, radix) {
        if (radix === void 0) { radix = 0; }
        var sign = 0;
        //This line was found in the source code but never used?
        var leadingZero = false;
        //This line makes the compiler think it was used.
        leadingZero;
        var length = string.length;
        var cursor = 0;
        if (cursor === length)
            return JSBI.__zero();
        var current = string.charCodeAt(cursor);
        // Skip whitespace.
        while (JSBI.__isWhitespace(current)) {
            if (++cursor === length)
                return JSBI.__zero();
            current = string.charCodeAt(cursor);
        }
        // Detect radix.
        if (current === 0x2B) { // '+'
            if (++cursor === length)
                return null;
            current = string.charCodeAt(cursor);
            sign = 1;
        }
        else if (current === 0x2D) { // '-'
            if (++cursor === length)
                return null;
            current = string.charCodeAt(cursor);
            sign = -1;
        }
        if (radix === 0) {
            radix = 10;
            if (current === 0x30) { // '0'
                if (++cursor === length)
                    return JSBI.__zero();
                current = string.charCodeAt(cursor);
                if (current === 0x58 || current === 0x78) { // 'X' or 'x'
                    radix = 16;
                    if (++cursor === length)
                        return null;
                    current = string.charCodeAt(cursor);
                }
                else if (current === 0x4F || current === 0x6F) { // 'O' or 'o'
                    radix = 8;
                    if (++cursor === length)
                        return null;
                    current = string.charCodeAt(cursor);
                }
                else if (current === 0x42 || current === 0x62) { // 'B' or 'b'
                    radix = 2;
                    if (++cursor === length)
                        return null;
                    current = string.charCodeAt(cursor);
                }
                else {
                    leadingZero = true;
                }
            }
        }
        else if (radix === 16) {
            if (current === 0x30) { // '0'
                // Allow "0x" prefix.
                if (++cursor === length)
                    return JSBI.__zero();
                current = string.charCodeAt(cursor);
                if (current === 0x58 || current === 0x78) { // 'X' or 'x'
                    if (++cursor === length)
                        return null;
                    current = string.charCodeAt(cursor);
                }
                else {
                    leadingZero = true;
                }
            }
        }
        // Skip leading zeros.
        while (current === 0x30) {
            leadingZero = true;
            if (++cursor === length)
                return JSBI.__zero();
            current = string.charCodeAt(cursor);
        }
        // Allocate result.
        var chars = length - cursor;
        var bitsPerChar = JSBI.__kMaxBitsPerChar[radix];
        var roundup = JSBI.__kBitsPerCharTableMultiplier - 1;
        if (chars > (1 << 30) / bitsPerChar)
            return null;
        var bitsMin = (bitsPerChar * chars + roundup) >>> JSBI.__kBitsPerCharTableShift;
        var resultLength = (bitsMin + 31) >>> 5;
        var result = new JSBI(resultLength, false);
        // Parse.
        var limDigit = radix < 10 ? radix : 10;
        var limAlpha = radix > 10 ? radix - 10 : 0;
        if ((radix & (radix - 1)) === 0) {
            // Power-of-two radix.
            bitsPerChar >>= JSBI.__kBitsPerCharTableShift;
            var parts = [];
            var partsBits = [];
            var done = false;
            do {
                var part = 0;
                var bits = 0;
                while (true) {
                    var d = void 0;
                    if (((current - 48) >>> 0) < limDigit) {
                        d = current - 48;
                    }
                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {
                        d = (current | 32) - 87;
                    }
                    else {
                        done = true;
                        break;
                    }
                    bits += bitsPerChar;
                    part = (part << bitsPerChar) | d;
                    if (++cursor === length) {
                        done = true;
                        break;
                    }
                    current = string.charCodeAt(cursor);
                    if (bits + bitsPerChar > 32)
                        break;
                }
                parts.push(part);
                partsBits.push(bits);
            } while (!done);
            JSBI.__fillFromParts(result, parts, partsBits);
        }
        else {
            result.__initializeDigits();
            var done = false;
            var charsSoFar = 0;
            do {
                var part = 0;
                var multiplier = 1;
                while (true) {
                    var d = void 0;
                    if (((current - 48) >>> 0) < limDigit) {
                        d = current - 48;
                    }
                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {
                        d = (current | 32) - 87;
                    }
                    else {
                        done = true;
                        break;
                    }
                    var m = multiplier * radix;
                    if (m > 0xFFFFFFFF)
                        break;
                    multiplier = m;
                    part = part * radix + d;
                    charsSoFar++;
                    if (++cursor === length) {
                        done = true;
                        break;
                    }
                    current = string.charCodeAt(cursor);
                }
                roundup = JSBI.__kBitsPerCharTableMultiplier * 32 - 1;
                var digitsSoFar = (bitsPerChar * charsSoFar + roundup) >>>
                    (JSBI.__kBitsPerCharTableShift + 5);
                result.__inplaceMultiplyAdd(multiplier, part, digitsSoFar);
            } while (!done);
        }
        while (cursor !== length) {
            if (!JSBI.__isWhitespace(current))
                return null;
            current = string.charCodeAt(cursor++);
        }
        // Get result.
        if (sign !== 0 && radix !== 10)
            return null;
        result.sign = (sign === -1);
        return result.__trim();
    };
    JSBI.__fillFromParts = function (result, parts, partsBits) {
        var digitIndex = 0;
        var digit = 0;
        var bitsInDigit = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
            var part = parts[i];
            var partBits = partsBits[i];
            digit |= (part << bitsInDigit);
            bitsInDigit += partBits;
            if (bitsInDigit === 32) {
                result.__setDigit(digitIndex++, digit);
                bitsInDigit = 0;
                digit = 0;
            }
            else if (bitsInDigit > 32) {
                result.__setDigit(digitIndex++, digit);
                bitsInDigit -= 32;
                digit = part >>> (partBits - bitsInDigit);
            }
        }
        if (digit !== 0) {
            if (digitIndex >= result.length)
                throw new Error('implementation bug');
            result.__setDigit(digitIndex++, digit);
        }
        for (; digitIndex < result.length; digitIndex++) {
            result.__setDigit(digitIndex, 0);
        }
    };
    JSBI.__toStringBasePowerOfTwo = function (x, radix) {
        var length = x.length;
        var bits = radix - 1;
        bits = ((bits >>> 1) & 0x55) + (bits & 0x55);
        bits = ((bits >>> 2) & 0x33) + (bits & 0x33);
        bits = ((bits >>> 4) & 0x0F) + (bits & 0x0F);
        var bitsPerChar = bits;
        var charMask = radix - 1;
        var msd = x.__digit(length - 1);
        var msdLeadingZeros = Math.clz32(msd);
        var bitLength = length * 32 - msdLeadingZeros;
        var charsRequired = ((bitLength + bitsPerChar - 1) / bitsPerChar) | 0;
        if (x.sign)
            charsRequired++;
        if (charsRequired > (1 << 28))
            throw new Error('string too long');
        var result = new Array(charsRequired);
        var pos = charsRequired - 1;
        var digit = 0;
        var availableBits = 0;
        for (var i = 0; i < length - 1; i++) {
            var newDigit = x.__digit(i);
            var current_1 = (digit | (newDigit << availableBits)) & charMask;
            result[pos--] = JSBI.__kConversionChars[current_1];
            var consumedBits = bitsPerChar - availableBits;
            digit = newDigit >>> consumedBits;
            availableBits = 32 - consumedBits;
            while (availableBits >= bitsPerChar) {
                result[pos--] = JSBI.__kConversionChars[digit & charMask];
                digit >>>= bitsPerChar;
                availableBits -= bitsPerChar;
            }
        }
        var current = (digit | (msd << availableBits)) & charMask;
        result[pos--] = JSBI.__kConversionChars[current];
        digit = msd >>> (bitsPerChar - availableBits);
        while (digit !== 0) {
            result[pos--] = JSBI.__kConversionChars[digit & charMask];
            digit >>>= bitsPerChar;
        }
        if (x.sign)
            result[pos--] = '-';
        if (pos !== -1)
            throw new Error('implementation bug');
        return result.join('');
    };
    JSBI.__toStringGeneric = function (x, radix, isRecursiveCall) {
        var length = x.length;
        if (length === 0)
            return '';
        if (length === 1) {
            var result = x.__unsignedDigit(0).toString(radix);
            if (isRecursiveCall === false && x.sign) {
                result = '-' + result;
            }
            return result;
        }
        var bitLength = length * 32 - Math.clz32(x.__digit(length - 1));
        var maxBitsPerChar = JSBI.__kMaxBitsPerChar[radix];
        var minBitsPerChar = maxBitsPerChar - 1;
        var charsRequired = bitLength * JSBI.__kBitsPerCharTableMultiplier;
        charsRequired += minBitsPerChar - 1;
        charsRequired = (charsRequired / minBitsPerChar) | 0;
        var secondHalfChars = (charsRequired + 1) >> 1;
        // Divide-and-conquer: split by a power of {radix} that's approximately
        // the square root of {x}, then recurse.
        var conqueror = JSBI.exponentiate(JSBI.__oneDigit(radix, false), JSBI.__oneDigit(secondHalfChars, false));
        var quotient;
        var secondHalf;
        var divisor = conqueror.__unsignedDigit(0);
        if (conqueror.length === 1 && divisor <= 0xFFFF) {
            quotient = new JSBI(x.length, false);
            quotient.__initializeDigits();
            var remainder = 0;
            for (var i = x.length * 2 - 1; i >= 0; i--) {
                var input = (remainder << 16) | x.__halfDigit(i);
                quotient.__setHalfDigit(i, (input / divisor) | 0);
                remainder = (input % divisor) | 0;
            }
            secondHalf = remainder.toString(radix);
        }
        else {
            var divisionResult = JSBI.__absoluteDivLarge(x, conqueror, true, true);
            quotient = divisionResult.quotient;
            var remainder = divisionResult.remainder.__trim();
            secondHalf = JSBI.__toStringGeneric(remainder, radix, true);
        }
        quotient.__trim();
        var firstHalf = JSBI.__toStringGeneric(quotient, radix, true);
        while (secondHalf.length < secondHalfChars) {
            secondHalf = '0' + secondHalf;
        }
        if (isRecursiveCall === false && x.sign) {
            firstHalf = '-' + firstHalf;
        }
        return firstHalf + secondHalf;
    };
    JSBI.__unequalSign = function (leftNegative) {
        return leftNegative ? -1 : 1;
    };
    JSBI.__absoluteGreater = function (bothNegative) {
        return bothNegative ? -1 : 1;
    };
    JSBI.__absoluteLess = function (bothNegative) {
        return bothNegative ? 1 : -1;
    };
    JSBI.__compareToBigInt = function (x, y) {
        var xSign = x.sign;
        if (xSign !== y.sign)
            return JSBI.__unequalSign(xSign);
        var result = JSBI.__absoluteCompare(x, y);
        if (result > 0)
            return JSBI.__absoluteGreater(xSign);
        if (result < 0)
            return JSBI.__absoluteLess(xSign);
        return 0;
    };
    JSBI.__compareToNumber = function (x, y) {
        /**
         * @todo Investigate this weird `0 === 0` construct
         */
        if (y | (0 === 0)) {
            var xSign = x.sign;
            var ySign = (y < 0);
            if (xSign !== ySign)
                return JSBI.__unequalSign(xSign);
            if (x.length === 0) {
                if (ySign)
                    throw new Error('implementation bug');
                return y === 0 ? 0 : -1;
            }
            // Any multi-digit BigInt is bigger than an int32.
            if (x.length > 1)
                return JSBI.__absoluteGreater(xSign);
            var yAbs = Math.abs(y);
            var xDigit = x.__unsignedDigit(0);
            if (xDigit > yAbs)
                return JSBI.__absoluteGreater(xSign);
            if (xDigit < yAbs)
                return JSBI.__absoluteLess(xSign);
            return 0;
        }
        return JSBI.__compareToDouble(x, y);
    };
    /**
     * @returns NaN|-1|1|0
     *
     * + NaN    : `y` was `NaN`
     * + -1     : `x < y`
     * + +1     : `x > y`
     * +  0     : `x == y`
     */
    JSBI.__compareToDouble = function (x, y) {
        if (y !== y)
            return y; // NaN.
        if (y === Infinity)
            return -1;
        if (y === -Infinity)
            return 1;
        var xSign = x.sign;
        var ySign = (y < 0);
        if (xSign !== ySign)
            return JSBI.__unequalSign(xSign);
        if (y === 0) {
            throw new Error('implementation bug: should be handled elsewhere');
        }
        if (x.length === 0)
            return -1;
        JSBI.__kBitConversionDouble[0] = y;
        var rawExponent = (JSBI.__kBitConversionInts[1] >>> 20) & 0x7FF;
        if (rawExponent === 0x7FF) {
            throw new Error('implementation bug: handled elsewhere');
        }
        var exponent = rawExponent - 0x3FF;
        if (exponent < 0) {
            // The absolute value of y is less than 1. Only 0n has an absolute
            // value smaller than that, but we've already covered that case.
            return JSBI.__absoluteGreater(xSign);
        }
        var xLength = x.length;
        var xMsd = x.__digit(xLength - 1);
        var msdLeadingZeros = Math.clz32(xMsd);
        var xBitLength = xLength * 32 - msdLeadingZeros;
        var yBitLength = exponent + 1;
        if (xBitLength < yBitLength)
            return JSBI.__absoluteLess(xSign);
        if (xBitLength > yBitLength)
            return JSBI.__absoluteGreater(xSign);
        // Same sign, same bit length. Shift mantissa to align with x and compare
        // bit for bit.
        var kHiddenBit = 0x00100000;
        var mantissaHigh = (JSBI.__kBitConversionInts[1] & 0xFFFFF) | kHiddenBit;
        var mantissaLow = JSBI.__kBitConversionInts[0];
        var kMantissaHighTopBit = 20;
        var msdTopBit = 31 - msdLeadingZeros;
        if (msdTopBit !== ((xBitLength - 1) % 31)) {
            throw new Error('implementation bug');
        }
        var compareMantissa; // Shifted chunk of mantissa.
        var remainingMantissaBits = 0;
        // First, compare most significant digit against beginning of mantissa.
        if (msdTopBit < kMantissaHighTopBit) {
            var shift = kMantissaHighTopBit - msdTopBit;
            remainingMantissaBits = shift + 32;
            compareMantissa = mantissaHigh >>> shift;
            mantissaHigh = (mantissaHigh << (32 - shift)) | (mantissaLow >>> shift);
            mantissaLow = mantissaLow << (32 - shift);
        }
        else if (msdTopBit === kMantissaHighTopBit) {
            remainingMantissaBits = 32;
            compareMantissa = mantissaHigh;
            mantissaHigh = mantissaLow;
        }
        else {
            var shift = msdTopBit - kMantissaHighTopBit;
            remainingMantissaBits = 32 - shift;
            compareMantissa =
                (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));
            mantissaHigh = mantissaLow << shift;
        }
        xMsd = xMsd >>> 0;
        compareMantissa = compareMantissa >>> 0;
        if (xMsd > compareMantissa)
            return JSBI.__absoluteGreater(xSign);
        if (xMsd < compareMantissa)
            return JSBI.__absoluteLess(xSign);
        // Then, compare additional digits against remaining mantissa bits.
        for (var digitIndex = xLength - 2; digitIndex >= 0; digitIndex--) {
            if (remainingMantissaBits > 0) {
                remainingMantissaBits -= 32;
                compareMantissa = mantissaHigh >>> 0;
                mantissaHigh = mantissaLow;
                mantissaLow = 0;
            }
            else {
                compareMantissa = 0;
            }
            var digit = x.__unsignedDigit(digitIndex);
            if (digit > compareMantissa)
                return JSBI.__absoluteGreater(xSign);
            if (digit < compareMantissa)
                return JSBI.__absoluteLess(xSign);
        }
        // Integer parts are equal; check whether {y} has a fractional part.
        if (mantissaHigh !== 0 || mantissaLow !== 0) {
            if (remainingMantissaBits === 0)
                throw new Error('implementation bug');
            return JSBI.__absoluteLess(xSign);
        }
        return 0;
    };
    JSBI.__equalToNumber = function (x, y) {
        if (y | (0 === y)) {
            if (y === 0)
                return x.length === 0;
            // Any multi-digit BigInt is bigger than an int32.
            return (x.length === 1) && (x.sign === (y < 0)) &&
                (x.__unsignedDigit(0) === Math.abs(y));
        }
        return JSBI.__compareToDouble(x, y) === 0;
    };
    // Comparison operations, chosen such that "op ^ 2" reverses direction:
    // 0 - lessThan
    // 1 - lessThanOrEqual
    // 2 - greaterThan
    // 3 - greaterThanOrEqual
    JSBI.__comparisonResultToBool = function (result, op) {
        switch (op) {
            case 0: return result < 0;
            case 1: return result <= 0;
            case 2: return result > 0;
            case 3: return result >= 0;
        }
        throw new Error('unreachable');
    };
    JSBI.__compare = function (x, y, op) {
        x = JSBI.__toPrimitive(x);
        y = JSBI.__toPrimitive(y);
        if (typeof x === 'string' && typeof y === 'string') {
            switch (op) {
                case 0: return x < y;
                case 1: return x <= y;
                case 2: return x > y;
                case 3: return x >= y;
            }
        }
        if (JSBI.__isBigInt(x) && typeof y === 'string') {
            y = JSBI.__fromString(y);
            if (y === null)
                return false;
            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);
        }
        if (typeof x === 'string' && JSBI.__isBigInt(y)) {
            x = JSBI.__fromString(x);
            if (x === null)
                return false;
            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);
        }
        if (x == null || y == null) {
            throw new Error("x and y should not be null");
        }
        x = JSBI.__toNumeric(x);
        y = JSBI.__toNumeric(y);
        if (JSBI.__isBigInt(x)) {
            if (JSBI.__isBigInt(y)) {
                return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);
            }
            if (typeof y !== 'number')
                throw new Error('implementation bug');
            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(x, y), op);
        }
        if (typeof x !== 'number')
            throw new Error('implementation bug');
        if (JSBI.__isBigInt(y)) {
            // Note that "op ^ 2" reverses the op's direction.
            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(y, x), (op ^ 2));
        }
        if (typeof y !== 'number')
            throw new Error('implementation bug');
        switch (op) {
            case 0: return x < y;
            case 1: return x <= y;
            case 2: return x > y;
            case 3: return x >= y;
        }
    };
    JSBI.prototype.__clzmsd = function () {
        return Math.clz32(this[this.length - 1]);
    };
    JSBI.__absoluteAdd = function (x, y, resultSign) {
        if (x.length < y.length)
            return JSBI.__absoluteAdd(y, x, resultSign);
        if (x.length === 0)
            return x;
        if (y.length === 0)
            return x.sign === resultSign ? x : JSBI.unaryMinus(x);
        var resultLength = x.length;
        if (x.__clzmsd() === 0 || (y.length === x.length && y.__clzmsd() === 0)) {
            resultLength++;
        }
        var result = new JSBI(resultLength, resultSign);
        var carry = 0;
        var i = 0;
        for (; i < y.length; i++) {
            var yDigit = y.__digit(i);
            var xDigit = x.__digit(i);
            var rLow = (xDigit & 0xFFFF) + (yDigit & 0xFFFF) + carry;
            var rHigh = (xDigit >>> 16) + (yDigit >>> 16) + (rLow >>> 16);
            carry = rHigh >>> 16;
            result.__setDigit(i, (rLow & 0xFFFF) | (rHigh << 16));
        }
        for (; i < x.length; i++) {
            var xDigit = x.__digit(i);
            var rLow = (xDigit & 0xFFFF) + carry;
            var rHigh = (xDigit >>> 16) + (rLow >>> 16);
            carry = rHigh >>> 16;
            result.__setDigit(i, (rLow & 0xFFFF) | (rHigh << 16));
        }
        if (i < result.length) {
            result.__setDigit(i, carry);
        }
        return result.__trim();
    };
    JSBI.__absoluteSub = function (x, y, resultSign) {
        if (x.length === 0)
            return x;
        if (y.length === 0)
            return x.sign === resultSign ? x : JSBI.unaryMinus(x);
        var result = new JSBI(x.length, resultSign);
        var borrow = 0;
        var i = 0;
        for (; i < y.length; i++) {
            var xDigit = x.__digit(i);
            var yDigit = y.__digit(i);
            var rLow = (xDigit & 0xFFFF) - (yDigit & 0xFFFF) - borrow;
            borrow = (rLow >>> 16) & 1;
            var rHigh = (xDigit >>> 16) - (yDigit >>> 16) - borrow;
            borrow = (rHigh >>> 16) & 1;
            result.__setDigit(i, (rLow & 0xFFFF) | (rHigh << 16));
        }
        for (; i < x.length; i++) {
            var xDigit = x.__digit(i);
            var rLow = (xDigit & 0xFFFF) - borrow;
            borrow = (rLow >>> 16) & 1;
            var rHigh = (xDigit >>> 16) - borrow;
            borrow = (rHigh >>> 16) & 1;
            result.__setDigit(i, (rLow & 0xFFFF) | (rHigh << 16));
        }
        return result.__trim();
    };
    JSBI.__absoluteAddOne = function (x, sign, result) {
        if (result === void 0) { result = null; }
        var inputLength = x.length;
        if (result === null) {
            result = new JSBI(inputLength, sign);
        }
        else {
            result.sign = sign;
        }
        var carry = true;
        for (var i = 0; i < inputLength; i++) {
            var digit = x.__digit(i);
            var newCarry = digit === (0xFFFFFFFF | 0);
            if (carry)
                digit = (digit + 1) | 0;
            carry = newCarry;
            result.__setDigit(i, digit);
        }
        if (carry) {
            result.__setDigitGrow(inputLength, 1);
        }
        return result;
    };
    JSBI.__absoluteSubOne = function (x, resultLength) {
        var length = x.length;
        resultLength = resultLength || length;
        var result = new JSBI(resultLength, false);
        var borrow = true;
        for (var i = 0; i < length; i++) {
            var digit = x.__digit(i);
            var newBorrow = digit === 0;
            if (borrow)
                digit = (digit - 1) | 0;
            borrow = newBorrow;
            result.__setDigit(i, digit);
        }
        for (var i = length; i < resultLength; i++) {
            result.__setDigit(i, 0);
        }
        return result;
    };
    JSBI.__absoluteAnd = function (x, y, result) {
        if (result === void 0) { result = null; }
        var xLength = x.length;
        var yLength = y.length;
        var numPairs = yLength;
        if (xLength < yLength) {
            numPairs = xLength;
            var tmp = x;
            var tmpLength = xLength;
            x = y;
            xLength = yLength;
            y = tmp;
            yLength = tmpLength;
        }
        var resultLength = numPairs;
        if (result === null) {
            result = new JSBI(resultLength, false);
        }
        else {
            resultLength = result.length;
        }
        var i = 0;
        for (; i < numPairs; i++) {
            result.__setDigit(i, x.__digit(i) & y.__digit(i));
        }
        for (; i < resultLength; i++) {
            result.__setDigit(i, 0);
        }
        return result;
    };
    JSBI.__absoluteAndNot = function (x, y, result) {
        if (result === void 0) { result = null; }
        var xLength = x.length;
        var yLength = y.length;
        var numPairs = yLength;
        if (xLength < yLength) {
            numPairs = xLength;
        }
        var resultLength = xLength;
        if (result === null) {
            result = new JSBI(resultLength, false);
        }
        else {
            resultLength = result.length;
        }
        var i = 0;
        for (; i < numPairs; i++) {
            result.__setDigit(i, x.__digit(i) & ~y.__digit(i));
        }
        for (; i < xLength; i++) {
            result.__setDigit(i, x.__digit(i));
        }
        for (; i < resultLength; i++) {
            result.__setDigit(i, 0);
        }
        return result;
    };
    JSBI.__absoluteOr = function (x, y, result) {
        if (result === void 0) { result = null; }
        var xLength = x.length;
        var yLength = y.length;
        var numPairs = yLength;
        if (xLength < yLength) {
            numPairs = xLength;
            var tmp = x;
            var tmpLength = xLength;
            x = y;
            xLength = yLength;
            y = tmp;
            yLength = tmpLength;
        }
        var resultLength = xLength;
        if (result === null) {
            result = new JSBI(resultLength, false);
        }
        else {
            resultLength = result.length;
        }
        var i = 0;
        for (; i < numPairs; i++) {
            result.__setDigit(i, x.__digit(i) | y.__digit(i));
        }
        for (; i < xLength; i++) {
            result.__setDigit(i, x.__digit(i));
        }
        for (; i < resultLength; i++) {
            result.__setDigit(i, 0);
        }
        return result;
    };
    JSBI.__absoluteXor = function (x, y, result) {
        if (result === void 0) { result = null; }
        var xLength = x.length;
        var yLength = y.length;
        var numPairs = yLength;
        if (xLength < yLength) {
            numPairs = xLength;
            var tmp = x;
            var tmpLength = xLength;
            x = y;
            xLength = yLength;
            y = tmp;
            yLength = tmpLength;
        }
        var resultLength = xLength;
        if (result === null) {
            result = new JSBI(resultLength, false);
        }
        else {
            resultLength = result.length;
        }
        var i = 0;
        for (; i < numPairs; i++) {
            result.__setDigit(i, x.__digit(i) ^ y.__digit(i));
        }
        for (; i < xLength; i++) {
            result.__setDigit(i, x.__digit(i));
        }
        for (; i < resultLength; i++) {
            result.__setDigit(i, 0);
        }
        return result;
    };
    JSBI.__absoluteCompare = function (x, y) {
        var diff = x.length - y.length;
        if (diff !== 0)
            return diff;
        var i = x.length - 1;
        while (i >= 0 && x.__digit(i) === y.__digit(i))
            i--;
        if (i < 0)
            return 0;
        return x.__unsignedDigit(i) > y.__unsignedDigit(i) ? 1 : -1;
    };
    JSBI.__multiplyAccumulate = function (multiplicand, multiplier, accumulator, accumulatorIndex) {
        if (multiplier === 0)
            return;
        var m2Low = multiplier & 0xFFFF;
        var m2High = multiplier >>> 16;
        var carry = 0;
        var highLower = 0;
        var highHigher = 0;
        for (var i = 0; i < multiplicand.length; i++, accumulatorIndex++) {
            var acc = accumulator.__digit(accumulatorIndex);
            var accLow = acc & 0xFFFF;
            var accHigh = acc >>> 16;
            var m1 = multiplicand.__digit(i);
            var m1Low = m1 & 0xFFFF;
            var m1High = m1 >>> 16;
            var rLow = Math.imul(m1Low, m2Low);
            var rMid1 = Math.imul(m1Low, m2High);
            var rMid2 = Math.imul(m1High, m2Low);
            var rHigh = Math.imul(m1High, m2High);
            accLow += highLower + (rLow & 0xFFFF);
            accHigh += highHigher + carry + (accLow >>> 16) + (rLow >>> 16) +
                (rMid1 & 0xFFFF) + (rMid2 & 0xFFFF);
            carry = accHigh >>> 16;
            highLower = (rMid1 >>> 16) + (rMid2 >>> 16) + (rHigh & 0xFFFF) + carry;
            carry = highLower >>> 16;
            highLower &= 0xFFFF;
            highHigher = rHigh >>> 16;
            acc = (accLow & 0xFFFF) | (accHigh << 16);
            accumulator.__setDigit(accumulatorIndex, acc);
        }
        for (; carry !== 0 || highLower !== 0 || highHigher !== 0; accumulatorIndex++) {
            var acc = accumulator.__digit(accumulatorIndex);
            var accLow = (acc & 0xFFFF) + highLower;
            var accHigh = (acc >>> 16) + (accLow >>> 16) + highHigher + carry;
            highLower = 0;
            highHigher = 0;
            carry = accHigh >>> 16;
            acc = (accLow & 0xFFFF) | (accHigh << 16);
            accumulator.__setDigit(accumulatorIndex, acc);
        }
    };
    JSBI.__internalMultiplyAdd = function (source, factor, summand, n, result) {
        var carry = summand;
        var high = 0;
        for (var i = 0; i < n; i++) {
            var digit = source.__digit(i);
            var rx = Math.imul(digit & 0xFFFF, factor);
            var r0 = (rx & 0xFFFF) + high + carry;
            carry = r0 >>> 16;
            var ry = Math.imul(digit >>> 16, factor);
            var r16 = (ry & 0xFFFF) + (rx >>> 16) + carry;
            carry = r16 >>> 16;
            high = ry >>> 16;
            result.__setDigit(i, (r16 << 16) | (r0 & 0xFFFF));
        }
        if (result.length > n) {
            result.__setDigit(n++, carry + high);
            while (n < result.length) {
                result.__setDigit(n++, 0);
            }
        }
        else {
            if (carry + high !== 0)
                throw new Error('implementation bug');
        }
    };
    JSBI.prototype.__inplaceMultiplyAdd = function (multiplier, summand, length) {
        if (length > this.length)
            length = this.length;
        var mLow = multiplier & 0xFFFF;
        var mHigh = multiplier >>> 16;
        var carry = 0;
        var highLower = summand & 0xFFFF;
        var highHigher = summand >>> 16;
        for (var i = 0; i < length; i++) {
            var d = this.__digit(i);
            var dLow = d & 0xFFFF;
            var dHigh = d >>> 16;
            var pLow = Math.imul(dLow, mLow);
            var pMid1 = Math.imul(dLow, mHigh);
            var pMid2 = Math.imul(dHigh, mLow);
            var pHigh = Math.imul(dHigh, mHigh);
            var rLow = highLower + (pLow & 0xFFFF);
            var rHigh = highHigher + carry + (rLow >>> 16) + (pLow >>> 16) +
                (pMid1 & 0xFFFF) + (pMid2 & 0xFFFF);
            highLower = (pMid1 >>> 16) + (pMid2 >>> 16) + (pHigh & 0xFFFF) +
                (rHigh >>> 16);
            carry = highLower >>> 16;
            highLower &= 0xFFFF;
            highHigher = pHigh >>> 16;
            var result = (rLow & 0xFFFF) | (rHigh << 16);
            this.__setDigit(i, result);
        }
        if (carry !== 0 || highLower !== 0 || highHigher !== 0) {
            throw new Error('implementation bug');
        }
    };
    JSBI.__absoluteDivSmall = function (x, divisor, quotient) {
        if (quotient === null)
            quotient = new JSBI(x.length, false);
        var remainder = 0;
        for (var i = x.length * 2 - 1; i >= 0; i -= 2) {
            var input = ((remainder << 16) | x.__halfDigit(i)) >>> 0;
            var upperHalf = (input / divisor) | 0;
            remainder = (input % divisor) | 0;
            input = ((remainder << 16) | x.__halfDigit(i - 1)) >>> 0;
            var lowerHalf = (input / divisor) | 0;
            remainder = (input % divisor) | 0;
            quotient.__setDigit(i >>> 1, (upperHalf << 16) | lowerHalf);
        }
        return quotient;
    };
    JSBI.__absoluteModSmall = function (x, divisor) {
        var remainder = 0;
        for (var i = x.length * 2 - 1; i >= 0; i--) {
            var input = ((remainder << 16) | x.__halfDigit(i)) >>> 0;
            remainder = (input % divisor) | 0;
        }
        return remainder;
    };
    JSBI.__absoluteDivLarge = function (dividend, divisor, wantQuotient, wantRemainder) {
        var n = divisor.__halfDigitLength();
        var n2 = divisor.length;
        var m = dividend.__halfDigitLength() - n;
        var q = null;
        if (wantQuotient) {
            q = new JSBI((m + 2) >>> 1, false);
            q.__initializeDigits();
        }
        var qhatv = new JSBI((n + 2) >>> 1, false);
        qhatv.__initializeDigits();
        // D1.
        var shift = JSBI.__clz16(divisor.__halfDigit(n - 1));
        if (shift > 0) {
            divisor = JSBI.__specialLeftShift(divisor, shift, 0 /* add no digits*/);
        }
        var u = JSBI.__specialLeftShift(dividend, shift, 1 /* add one digit */);
        // D2.
        var vn1 = divisor.__halfDigit(n - 1);
        var halfDigitBuffer = 0;
        for (var j = m; j >= 0; j--) {
            // D3.
            var qhat = 0xFFFF;
            var ujn = u.__halfDigit(j + n);
            if (ujn !== vn1) {
                var input = ((ujn << 16) | u.__halfDigit(j + n - 1)) >>> 0;
                qhat = (input / vn1) | 0;
                var rhat = (input % vn1) | 0;
                var vn2 = divisor.__halfDigit(n - 2);
                var ujn2 = u.__halfDigit(j + n - 2);
                while ((Math.imul(qhat, vn2) >>> 0) > (((rhat << 16) | ujn2) >>> 0)) {
                    qhat--;
                    rhat += vn1;
                    if (rhat > 0xFFFF)
                        break;
                }
            }
            // D4.
            JSBI.__internalMultiplyAdd(divisor, qhat, 0, n2, qhatv);
            var c = u.__inplaceSub(qhatv, j, n + 1);
            if (c !== 0) {
                c = u.__inplaceAdd(divisor, j, n);
                u.__setHalfDigit(j + n, u.__halfDigit(j + n) + c);
                qhat--;
            }
            if (wantQuotient && q != null) {
                if (j & 1) {
                    halfDigitBuffer = qhat << 16;
                }
                else {
                    q.__setDigit(j >>> 1, halfDigitBuffer | qhat);
                }
            }
        }
        if (wantRemainder) {
            u.__inplaceRightShift(shift);
            if (wantQuotient && q != null) {
                return { quotient: q, remainder: u };
            }
            return u;
        }
        if (wantQuotient && q != null)
            return q;
        throw new Error("Either wantQuotient or wantRemainder must be set");
    };
    JSBI.__clz16 = function (value) {
        return Math.clz32(value) - 16;
    };
    // TODO: work on full digits, like __inplaceSub?
    JSBI.prototype.__inplaceAdd = function (summand, startIndex, halfDigits) {
        var carry = 0;
        for (var i = 0; i < halfDigits; i++) {
            var sum = this.__halfDigit(startIndex + i) +
                summand.__halfDigit(i) +
                carry;
            carry = sum >>> 16;
            this.__setHalfDigit(startIndex + i, sum);
        }
        return carry;
    };
    JSBI.prototype.__inplaceSub = function (subtrahend, startIndex, halfDigits) {
        var fullSteps = (halfDigits - 1) >>> 1;
        var borrow = 0;
        if (startIndex & 1) {
            // this:   [..][..][..]
            // subtr.:   [..][..]
            startIndex >>= 1;
            var current = this.__digit(startIndex);
            var r0 = current & 0xFFFF;
            var i = 0;
            for (; i < fullSteps; i++) {
                var sub_1 = subtrahend.__digit(i);
                var r16_1 = (current >>> 16) - (sub_1 & 0xFFFF) - borrow;
                borrow = (r16_1 >>> 16) & 1;
                this.__setDigit(startIndex + i, (r16_1 << 16) | (r0 & 0xFFFF));
                current = this.__digit(startIndex + i + 1);
                r0 = (current & 0xFFFF) - (sub_1 >>> 16) - borrow;
                borrow = (r0 >>> 16) & 1;
            }
            // Unrolling the last iteration gives a 5% performance benefit!
            var sub = subtrahend.__digit(i);
            var r16 = (current >>> 16) - (sub & 0xFFFF) - borrow;
            borrow = (r16 >>> 16) & 1;
            this.__setDigit(startIndex + i, (r16 << 16) | (r0 & 0xFFFF));
            var subTop = sub >>> 16;
            if (startIndex + i + 1 >= this.length) {
                throw new RangeError('out of bounds');
            }
            if ((halfDigits & 1) === 0) {
                current = this.__digit(startIndex + i + 1);
                r0 = (current & 0xFFFF) - subTop - borrow;
                borrow = (r0 >>> 16) & 1;
                this.__setDigit(startIndex + subtrahend.length, (current & 0xFFFF0000) | (r0 & 0xFFFF));
            }
        }
        else {
            startIndex >>= 1;
            var i = 0;
            for (; i < subtrahend.length - 1; i++) {
                var current_2 = this.__digit(startIndex + i);
                var sub_2 = subtrahend.__digit(i);
                var r0_1 = (current_2 & 0xFFFF) - (sub_2 & 0xFFFF) - borrow;
                borrow = (r0_1 >>> 16) & 1;
                var r16_2 = (current_2 >>> 16) - (sub_2 >>> 16) - borrow;
                borrow = (r16_2 >>> 16) & 1;
                this.__setDigit(startIndex + i, (r16_2 << 16) | (r0_1 & 0xFFFF));
            }
            var current = this.__digit(startIndex + i);
            var sub = subtrahend.__digit(i);
            var r0 = (current & 0xFFFF) - (sub & 0xFFFF) - borrow;
            borrow = (r0 >>> 16) & 1;
            var r16 = 0;
            if ((halfDigits & 1) === 0) {
                r16 = (current >>> 16) - (sub >>> 16) - borrow;
                borrow = (r16 >>> 16) & 1;
            }
            this.__setDigit(startIndex + i, (r16 << 16) | (r0 & 0xFFFF));
        }
        return borrow;
    };
    JSBI.prototype.__inplaceRightShift = function (shift) {
        if (shift === 0)
            return;
        var carry = this.__digit(0) >>> shift;
        var last = this.length - 1;
        for (var i = 0; i < last; i++) {
            var d = this.__digit(i + 1);
            this.__setDigit(i, (d << (32 - shift)) | carry);
            carry = d >>> shift;
        }
        this.__setDigit(last, carry);
    };
    JSBI.__specialLeftShift = function (x, shift, addDigit) {
        var n = x.length;
        var resultLength = n + addDigit;
        var result = new JSBI(resultLength, false);
        if (shift === 0) {
            for (var i = 0; i < n; i++)
                result.__setDigit(i, x.__digit(i));
            if (addDigit > 0)
                result.__setDigit(n, 0);
            return result;
        }
        var carry = 0;
        for (var i = 0; i < n; i++) {
            var d = x.__digit(i);
            result.__setDigit(i, (d << shift) | carry);
            carry = d >>> (32 - shift);
        }
        if (addDigit > 0) {
            result.__setDigit(n, carry);
        }
        return result;
    };
    JSBI.__leftShiftByAbsolute = function (x, y) {
        var shift = JSBI.__toShiftAmount(y);
        if (shift < 0)
            throw new RangeError('BigInt too big');
        var digitShift = shift >>> 5;
        var bitsShift = shift & 31;
        var length = x.length;
        var grow = bitsShift !== 0 &&
            (x.__digit(length - 1) >>> (32 - bitsShift)) !== 0;
        var resultLength = length + digitShift + (grow ? 1 : 0);
        var result = new JSBI(resultLength, x.sign);
        if (bitsShift === 0) {
            var i = 0;
            for (; i < digitShift; i++)
                result.__setDigit(i, 0);
            for (; i < resultLength; i++) {
                result.__setDigit(i, x.__digit(i - digitShift));
            }
        }
        else {
            var carry = 0;
            for (var i = 0; i < digitShift; i++)
                result.__setDigit(i, 0);
            for (var i = 0; i < length; i++) {
                var d = x.__digit(i);
                result.__setDigit(i + digitShift, (d << bitsShift) | carry);
                carry = d >>> (32 - bitsShift);
            }
            if (grow) {
                result.__setDigit(length + digitShift, carry);
            }
            else {
                if (carry !== 0)
                    throw new Error('implementation bug');
            }
        }
        return result.__trim();
    };
    JSBI.__rightShiftByAbsolute = function (x, y) {
        var length = x.length;
        var sign = x.sign;
        var shift = JSBI.__toShiftAmount(y);
        if (shift < 0)
            return JSBI.__rightShiftByMaximum(sign);
        var digitShift = shift >>> 5;
        var bitsShift = shift & 31;
        var resultLength = length - digitShift;
        if (resultLength <= 0)
            return JSBI.__rightShiftByMaximum(sign);
        // For negative numbers, round down if any bit was shifted out (so that
        // e.g. -5n >> 1n == -3n and not -2n). Check now whether this will happen
        // and whether itc an cause overflow into a new digit. If we allocate the
        // result large enough up front, it avoids having to do grow it later.
        var mustRoundDown = false;
        if (sign) {
            var mask = (1 << bitsShift) - 1;
            if ((x.__digit(digitShift) & mask) !== 0) {
                mustRoundDown = true;
            }
            else {
                for (var i = 0; i < digitShift; i++) {
                    if (x.__digit(i) !== 0) {
                        mustRoundDown = true;
                        break;
                    }
                }
            }
        }
        // If bitsShift is non-zero, it frees up bits, preventing overflow.
        if (mustRoundDown && bitsShift === 0) {
            // Overflow cannot happen if the most significant digit has unset bits.
            var msd = x.__digit(length - 1);
            var roundingCanOverflow = ~msd === 0;
            if (roundingCanOverflow)
                resultLength++;
        }
        var result = new JSBI(resultLength, sign);
        if (bitsShift === 0) {
            for (var i = digitShift; i < length; i++) {
                result.__setDigit(i - digitShift, x.__digit(i));
            }
        }
        else {
            var carry = x.__digit(digitShift) >>> bitsShift;
            var last = length - digitShift - 1;
            for (var i = 0; i < last; i++) {
                var d = x.__digit(i + digitShift + 1);
                result.__setDigit(i, (d << (32 - bitsShift)) | carry);
                carry = d >>> bitsShift;
            }
            result.__setDigit(last, carry);
        }
        if (mustRoundDown) {
            // Since the result is negative, rounding down means adding one to its
            // absolute value. This cannot overflow.
            result = JSBI.__absoluteAddOne(result, true, result);
        }
        return result.__trim();
    };
    JSBI.__rightShiftByMaximum = function (sign) {
        if (sign) {
            return JSBI.__oneDigit(1, true);
        }
        return JSBI.__zero();
    };
    JSBI.__toShiftAmount = function (x) {
        if (x.length > 1)
            return -1;
        var value = x.__unsignedDigit(0);
        if (value > JSBI.__kMaxLengthBits)
            return -1;
        return value;
    };
    JSBI.__toPrimitive = function (obj, hint) {
        if (hint === void 0) { hint = 'default'; }
        if (typeof obj !== 'object')
            return obj;
        if (obj.constructor === JSBI)
            return obj;
        var exoticToPrim = Symbol.toPrimitive == undefined ? undefined : obj[Symbol.toPrimitive];
        if (exoticToPrim) {
            var primitive = exoticToPrim(hint);
            if (typeof primitive !== 'object')
                return primitive;
            throw new TypeError('Cannot convert object to primitive value');
        }
        var valueOf = obj.valueOf;
        if (valueOf) {
            var primitive = valueOf.call(obj);
            if (typeof primitive !== 'object')
                return primitive;
        }
        var toString = obj.toString;
        if (toString) {
            var primitive = toString.call(obj);
            if (typeof primitive !== 'object')
                return primitive;
        }
        throw new TypeError('Cannot convert object to primitive value');
    };
    JSBI.__toNumeric = function (value) {
        if (JSBI.__isBigInt(value))
            return value;
        return +value;
    };
    JSBI.__isBigInt = function (value) {
        return typeof value === 'object' && value.constructor === JSBI;
    };
    JSBI.__truncateToNBits = function (n, x) {
        var neededDigits = (n + 31) >>> 5;
        var result = new JSBI(neededDigits, x.sign);
        var last = neededDigits - 1;
        for (var i = 0; i < last; i++) {
            result.__setDigit(i, x.__digit(i));
        }
        var msd = x.__digit(last);
        if ((n & 31) !== 0) {
            var drop = 32 - (n & 31);
            msd = (msd << drop) >>> drop;
        }
        result.__setDigit(last, msd);
        return result.__trim();
    };
    JSBI.__truncateAndSubFromPowerOfTwo = function (n, x, resultSign) {
        var neededDigits = (n + 31) >>> 5;
        var result = new JSBI(neededDigits, resultSign);
        var i = 0;
        var last = neededDigits - 1;
        var borrow = 0;
        var limit = Math.min(last, x.length);
        for (; i < limit; i++) {
            var xDigit = x.__digit(i);
            var rLow = 0 - (xDigit & 0xFFFF) - borrow;
            borrow = (rLow >>> 16) & 1;
            var rHigh = 0 - (xDigit >>> 16) - borrow;
            borrow = (rHigh >>> 16) & 1;
            result.__setDigit(i, (rLow & 0xFFFF) | (rHigh << 16));
        }
        for (; i < last; i++) {
            result.__setDigit(i, (-borrow) | 0);
        }
        var msd = last < x.length ? x.__digit(last) : 0;
        var msdBitsConsumed = n & 31;
        var resultMsd;
        if (msdBitsConsumed === 0) {
            var rLow = 0 - (msd & 0xFFFF) - borrow;
            borrow = (rLow >>> 16) & 1;
            var rHigh = 0 - (msd >>> 16) - borrow;
            resultMsd = (rLow & 0xFFFF) | (rHigh << 16);
        }
        else {
            var drop = 32 - msdBitsConsumed;
            msd = (msd << drop) >>> drop;
            var minuendMsd = 1 << (32 - drop);
            var rLow = (minuendMsd & 0xFFFF) - (msd & 0xFFFF) - borrow;
            borrow = (rLow >>> 16) & 1;
            var rHigh = (minuendMsd >>> 16) - (msd >>> 16) - borrow;
            resultMsd = (rLow & 0xFFFF) | (rHigh << 16);
            resultMsd &= (minuendMsd - 1);
        }
        result.__setDigit(last, resultMsd);
        return result.__trim();
    };
    // Digit helpers.
    JSBI.prototype.__digit = function (i) {
        return this[i];
    };
    JSBI.prototype.__unsignedDigit = function (i) {
        return this[i] >>> 0;
    };
    JSBI.prototype.__setDigit = function (i, digit) {
        this[i] = digit | 0;
    };
    JSBI.prototype.__setDigitGrow = function (i, digit) {
        this[i] = digit | 0;
    };
    JSBI.prototype.__halfDigitLength = function () {
        var len = this.length;
        if (this.__unsignedDigit(len - 1) <= 0xFFFF)
            return len * 2 - 1;
        return len * 2;
    };
    JSBI.prototype.__halfDigit = function (i) {
        return (this[i >>> 1] >>> ((i & 1) << 4)) & 0xFFFF;
    };
    JSBI.prototype.__setHalfDigit = function (i, value) {
        var digitIndex = i >>> 1;
        var previous = this.__digit(digitIndex);
        var updated = (i & 1) ? (previous & 0xFFFF) | (value << 16)
            : (previous & 0xFFFF0000) | (value & 0xFFFF);
        this.__setDigit(digitIndex, updated);
    };
    JSBI.__digitPow = function (base, exponent) {
        var result = 1;
        while (exponent > 0) {
            if (exponent & 1)
                result *= base;
            exponent >>>= 1;
            base *= base;
        }
        return result;
    };
    JSBI.__kMaxLength = 1 << 25;
    JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5;
    // Lookup table for the maximum number of bits required per character of a
    // base-N string representation of a number. To increase accuracy, the array
    // value is the actual value multiplied by 32. To generate this table:
    //
    // for (let i = 0; i <= 36; i++) {
    //   console.log(Math.ceil(Math.log2(i) * 32) + ',');
    // }
    JSBI.__kMaxBitsPerChar = [
        0, 0, 32, 51, 64, 75, 83, 90, 96,
        102, 107, 111, 115, 119, 122, 126, 128,
        131, 134, 136, 139, 141, 143, 145, 147,
        149, 151, 153, 154, 156, 158, 159, 160,
        162, 163, 165, 166,
    ];
    JSBI.__kBitsPerCharTableShift = 5;
    JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift;
    JSBI.__kConversionChars = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');
    JSBI.__kBitConversionBuffer = new ArrayBuffer(8);
    JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer);
    JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer);
    return JSBI;
}(Array));
exports.JSBI = JSBI;
//# sourceMappingURL=jsbi.js.map