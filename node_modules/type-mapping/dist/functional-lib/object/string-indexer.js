"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = require("../../mapper");
var operator_1 = require("../operator");
var instance_of_object_1 = require("./instance-of-object");
var string_util_1 = require("../../string-util");
var error_util_1 = require("../../error-util");
function unsafeStringIndexer(f) {
    var result = operator_1.pipe(instance_of_object_1.instanceOfObject(), function (name, obj) {
        var propertyErrors = [];
        var result = {};
        for (var k in obj) {
            if (!Object.prototype.hasOwnProperty.call(obj, k)) {
                continue;
            }
            var propertyResult = mapper_1.tryMapHandled(f, "" + name + string_util_1.toPropertyAccess(k), obj[k]);
            if (propertyResult.success) {
                result[k] = propertyResult.value;
            }
            else {
                propertyErrors.push(propertyResult.mappingError);
            }
        }
        if (propertyErrors.length == 0) {
            return result;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be valid object",
                inputName: name,
                actualValue: obj,
                expected: "valid object",
                propertyErrors: propertyErrors,
            });
        }
    });
    return mapper_1.copyRunTimeModifier(f, result);
}
exports.unsafeStringIndexer = unsafeStringIndexer;
function stringIndexer(f) {
    var fOrUndefined = operator_1.orUndefined(f);
    var result = operator_1.pipe(instance_of_object_1.instanceOfObject(), function (name, obj) {
        var propertyErrors = [];
        var result = {};
        for (var k in obj) {
            if (!Object.prototype.hasOwnProperty.call(obj, k)) {
                continue;
            }
            var propertyResult = mapper_1.tryMapHandled(fOrUndefined, "" + name + string_util_1.toPropertyAccess(k), obj[k]);
            if (propertyResult.success) {
                result[k] = propertyResult.value;
            }
            else {
                propertyErrors.push(propertyResult.mappingError);
            }
        }
        if (propertyErrors.length == 0) {
            return result;
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must be valid object",
                inputName: name,
                actualValue: obj,
                expected: "valid object",
                propertyErrors: propertyErrors,
            });
        }
    });
    return mapper_1.copyRunTimeModifier(f, result);
}
exports.stringIndexer = stringIndexer;
//# sourceMappingURL=string-indexer.js.map