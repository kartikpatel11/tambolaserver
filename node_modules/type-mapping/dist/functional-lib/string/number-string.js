"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = require("../operator");
var number_1 = require("../number");
var string_1 = require("./string");
var error_util_1 = require("../../error-util");
var FixedPointUtil = require("../../fixed-point-util");
var FloatingPointUtil = require("../../floating-point-util");
/**
    Just because a string is in floating point format does not mean
    it is a finite number.

    ```ts
    const nines_80 = "99999999999999999999999999999999999999999999999999999999999999999999999999999999";
    const nines_320 = nines_80.repeat(4);
    //This will pass, 320 nines in a row is a valid floating point format
    floatingPointFormatString()("", nines_320);
    //Infinity
    parseFloat(nines_320);
    ```

    + This mapper will trim strings before checking.
*/
function floatingPointFormatString() {
    return operator_1.pipe(string_1.toTrimmed(), string_1.match(FloatingPointUtil.floatingPointRegex, function (name) {
        return {
            message: name + " must be valid floating point format string",
            expected: "valid floating point format string",
        };
    }));
}
exports.floatingPointFormatString = floatingPointFormatString;
/**
    Just because a string is in integer format does not mean
    it is a finite number.

    ```ts
    const nines_80 = "99999999999999999999999999999999999999999999999999999999999999999999999999999999";
    const nines_320 = nines_80.repeat(4);
    //This will pass, 320 nines in a row is a valid integer format
    integerFormatString()("", nines_320);
    //Infinity
    parseFloat(nines_320);
    ```

    + This mapper will trim strings before checking.
    + This mapper allows scientific notation.
*/
function integerFormatString() {
    return operator_1.pipe(string_1.toTrimmed(), function (name, str) {
        var parsed = FixedPointUtil.tryParse(str);
        if (parsed == undefined || !parsed.isInteger) {
            throw error_util_1.makeMappingError({
                message: name + " must be a valid integer format string",
                inputName: name,
                actualValue: str,
                expected: "valid integer format string",
            });
        }
        return str;
    });
}
exports.integerFormatString = integerFormatString;
/**
    Just because a string is in unsigned number format does not mean
    it is a finite number.

    ```ts
    const nines_80 = "99999999999999999999999999999999999999999999999999999999999999999999999999999999";
    const nines_320 = nines_80.repeat(4);
    //This will pass, 320 nines in a row is a valid unsigned number format
    unsignedIntegerFormatString()("", nines_320);
    //Infinity
    parseFloat(nines_320);
    ```

    + This mapper will trim strings before checking.
    + This mapper allows scientific notation.
*/
function unsignedIntegerFormatString() {
    return operator_1.pipe(string_1.toTrimmed(), function (name, str) {
        var parsed = FixedPointUtil.tryParse(str);
        if (parsed == undefined || !parsed.isInteger || parsed.isNegative) {
            throw error_util_1.makeMappingError({
                message: name + " must be a valid unsigned integer format string",
                inputName: name,
                actualValue: str,
                expected: "valid unsigned integer format string",
            });
        }
        return str;
    });
}
exports.unsignedIntegerFormatString = unsignedIntegerFormatString;
/**
    Uses `floatingPointFormatString()` and `parseFloat()` internally.

    ```ts
    //Output is 10000000000000000 due to loss in precision
    finiteNumberString()("", "9999999999999999");
    ```
*/
function finiteNumberString() {
    var finiteNumberDelegate = number_1.finiteNumber();
    return operator_1.pipe(floatingPointFormatString(), function (name, str) {
        return finiteNumberDelegate("parseFloat(" + name + ")", parseFloat(str)).toString();
    });
}
exports.finiteNumberString = finiteNumberString;
/**
    Uses `integerFormatString()` and `parseFloat()` internally.

    ```ts
    //Output is 10000000000000000 due to loss in precision
    integerString()("", "9999999999999999");
    ```
*/
function integerString() {
    var integerDelegate = number_1.integer();
    return operator_1.pipe(integerFormatString(), function (name, str) {
        return integerDelegate("parseFloat(" + name + ")", parseFloat(str)).toString();
    });
}
exports.integerString = integerString;
/**
    Uses `unsignedIntegerString()` and `parseFloat()` internally.

    ```ts
    //Output is 10000000000000000 due to loss in precision
    integerString()("", "9999999999999999");
    ```
*/
function unsignedIntegerString() {
    var unsignedIntegerDelegate = number_1.unsignedInteger();
    return operator_1.pipe(unsignedIntegerFormatString(), function (name, str) {
        return unsignedIntegerDelegate("parseFloat(" + name + ")", parseFloat(str)).toString();
    });
}
exports.unsignedIntegerString = unsignedIntegerString;
//# sourceMappingURL=number-string.js.map