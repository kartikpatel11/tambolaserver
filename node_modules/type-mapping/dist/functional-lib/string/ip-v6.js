"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var operator_1 = require("../operator");
var string_1 = require("./string");
var array_util_1 = require("../../array-util");
var error_util_1 = require("../../error-util");
/**
    == INPUT ==
    https://tools.ietf.org/html/rfc4291#section-2.2

    Each IPv6 segment is any hexadecimal value between
    0 and ffff.

    Each segment is one to four hexadecimal digits.

    == OUTPUT ==
    https://tools.ietf.org/html/rfc5952#section-4.1
    Leading zeros MUST be suppressed.  For example, 2001:0db8::0001 is
    not acceptable and must be represented as 2001:db8::1.  A single 16-
    bit 0000 field MUST be represented as 0.

    https://tools.ietf.org/html/rfc5952#section-4.3

    The characters "a", "b", "c", "d", "e", and "f" in an IPv6 address
    MUST be represented in lowercase.
*/
function ipV6SegmentString() {
    return operator_1.pipe(string_1.stringLength({
        min: 1,
        max: 4,
    }), string_1.hexadecimalString(), function (_name, str) {
        if (/^0+$/.test(str)) {
            return "0";
        }
        return str.toLowerCase()
            .replace(/^0+/, "");
    });
}
exports.ipV6SegmentString = ipV6SegmentString;
function consecutiveZeroCount(segments, start) {
    var count = 0;
    while (segments[start] == "0") {
        ++count;
        ++start;
    }
    return count;
}
function largestConsecutiveZeroCount(segments) {
    var largestStart = 0;
    var largestCount = 0;
    var curStart = 0;
    while (curStart < segments.length) {
        var curCount = consecutiveZeroCount(segments, curStart);
        if (curCount > largestCount) {
            largestStart = curStart;
            largestCount = curCount;
        }
        ++curStart;
    }
    return {
        start: largestStart,
        count: largestCount,
        before: segments.slice(0, largestStart),
        after: segments.slice(largestStart + largestCount),
    };
}
/**
    https://tools.ietf.org/html/rfc5952#section-4.2.1

    The use of the symbol "::" MUST be used to its maximum capability.
    For example, 2001:db8:0:0:0:0:2:1 must be shortened to 2001:db8::2:1.
    Likewise, 2001:db8::0:1 is not acceptable, because the symbol "::"
    could have been used to produce a shorter representation 2001:db8::1.

    https://tools.ietf.org/html/rfc5952#section-4.2.2

    The symbol "::" MUST NOT be used to shorten just one 16-bit 0 field.
    For example, the representation 2001:db8:0:1:1:1:1:1 is correct, but
    2001:db8::1:1:1:1:1 is not correct.

    https://tools.ietf.org/html/rfc5952#section-4.2.3

    When there is an alternative choice in the placement of a "::", the
    longest run of consecutive 16-bit 0 fields MUST be shortened (i.e.,
    the sequence with three consecutive zero fields is shortened in 2001:
    0:0:1:0:0:0:1).  When the length of the consecutive 16-bit 0 fields
    are equal (i.e., 2001:db8:0:0:1:0:0:1), the first sequence of zero
    bits MUST be shortened.  For example, 2001:db8::1:0:0:1 is correct
    representation.
*/
function toIpV6CanonicalString(segments) {
    var result = largestConsecutiveZeroCount(segments);
    if (result.count <= 1) {
        return segments.join(":");
    }
    else {
        return (result.before.join(":") +
            "::" +
            result.after.join(":"));
    }
}
function ipV6StringWithMaxSegmentCount(maxSegmentCount) {
    var ipV6SegmentStringDelegate = ipV6SegmentString();
    return operator_1.pipe(string_1.string(), function (name, str) {
        var consecutiveNonZero = str
            .replace(/\s+/g, "")
            .split("::");
        if (consecutiveNonZero.length == 1) {
            //All non-zeroes
            var rawSegments = consecutiveNonZero[0].split(":");
            if (rawSegments.length != maxSegmentCount) {
                throw error_util_1.makeMappingError({
                    message: name + " must have " + maxSegmentCount + " segments; found " + rawSegments.length,
                    inputName: name,
                    actualValue: str,
                    expected: maxSegmentCount + " IPv6 segments",
                });
            }
            var segments = rawSegments
                .map(function (rawSegment, i) { return ipV6SegmentStringDelegate(name + " segment" + i, rawSegment); });
            return toIpV6CanonicalString(segments);
        }
        else if (consecutiveNonZero.length == 2) {
            //E.g. ffff:ffff::ffff:ffff:ffff
            var rawSegmentsA = consecutiveNonZero[0].split(":").filter(function (s) { return s != ""; });
            var rawSegmentsB = consecutiveNonZero[1].split(":").filter(function (s) { return s != ""; });
            var rawSegmentCount = rawSegmentsA.length + rawSegmentsB.length;
            if (rawSegmentCount >= maxSegmentCount) {
                throw error_util_1.makeMappingError({
                    message: name + " must have up to " + (maxSegmentCount - 1) + " segments when '::' symbol is used; found " + rawSegmentCount,
                    inputName: name,
                    actualValue: str,
                    expected: "up to " + (maxSegmentCount - 1) + " IPv6 segments",
                });
            }
            var segmentsA = rawSegmentsA
                .map(function (rawSegment, i) { return ipV6SegmentStringDelegate(name + " segment" + i, rawSegment); });
            var segmentBStart_1 = maxSegmentCount - rawSegmentsB.length;
            var segmentsB = rawSegmentsB
                .map(function (rawSegment, i) { return ipV6SegmentStringDelegate(name + " segment" + (segmentBStart_1 + i), rawSegment); });
            var zeroes = array_util_1.arrayFill(Array(maxSegmentCount - rawSegmentCount), "0");
            return toIpV6CanonicalString(segmentsA
                .concat(zeroes)
                .concat(segmentsB));
        }
        else {
            throw error_util_1.makeMappingError({
                message: name + " must have zero or one '::' symbol; found " + (consecutiveNonZero.length - 1) + " uses",
                inputName: name,
                actualValue: str,
                expected: "IPv6 string with zero or one '::' symbol",
            });
        }
    });
}
exports.ipV6StringWithMaxSegmentCount = ipV6StringWithMaxSegmentCount;
function ipV6String() {
    return ipV6StringWithMaxSegmentCount(8);
}
exports.ipV6String = ipV6String;
//# sourceMappingURL=ip-v6.js.map