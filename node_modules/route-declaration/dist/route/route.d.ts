import * as tm from "type-mapping";
import { Path } from "../path";
import { SetQuery, SetMethod, Append, AssertCanAppendParam, AppendParam, AssertCanSetParam, SetParam, UnsetParam, SetBody, SetHeader, SetResponse, DeepMergeQuery, AppendParamField, AssertValidParamField } from "./operation";
import { MethodOf } from "./query";
import { IsValid } from "./predicate";
/**
    TODO Does the "CONNECT" method make sense?
*/
export declare enum Method {
    GET = "GET",
    POST = "POST",
    PUT = "PUT",
    DELETE = "DELETE",
    PATCH = "PATCH",
    HEAD = "HEAD",
    OPTIONS = "OPTIONS",
    CONNECT = "CONNECT",
    /**
        If a route's method is "Contextual",
        then it is "GET" if there is no body mapper,
        and "POST" if there is.
    */
    Contextual = "Contextual"
}
export declare type MethodStr = keyof (typeof Method);
export interface RouteData {
    readonly method: MethodStr;
    readonly path: Path<string>;
    readonly param: undefined | tm.AnySafeMapper;
    readonly query: undefined | tm.AnySafeMapper;
    readonly body: undefined | tm.AnySafeMapper;
    readonly header: undefined | tm.AnySafeMapper;
    readonly response: undefined | tm.AnySafeMapper;
}
export interface DefaultRouteData {
    readonly method: Method.Contextual;
    readonly path: Path<never>;
    readonly param: undefined;
    readonly query: undefined;
    readonly body: undefined;
    readonly header: undefined;
    readonly response: undefined;
}
export declare class Route<DataT extends RouteData> {
    readonly method: DataT["method"];
    readonly path: DataT["path"];
    readonly param: DataT["param"];
    readonly query: DataT["query"];
    readonly body: DataT["body"];
    readonly header: DataT["header"];
    readonly response: DataT["response"];
    setMethod<MethodT extends MethodStr>(method: MethodT): SetMethod<DataT, MethodT>;
    getMethod(): MethodOf<this>;
    constructor(data: DataT);
    static Create(): Route<DefaultRouteData>;
    append(part: string): Append<DataT>;
    appendParam<NameT extends string>(this: AssertCanAppendParam<this>, name: NameT, regex?: RegExp): AppendParam<DataT, NameT>;
    appendParam<FieldT extends tm.AnyField>(this: this, field: AssertValidParamField<FieldT>, regex?: RegExp): AppendParamField<DataT, FieldT>;
    setParam<F extends tm.AnySafeMapper>(f: AssertCanSetParam<DataT, F>): SetParam<DataT, F>;
    unsetParam(): UnsetParam<DataT>;
    /**
        Your query mapper should handle the following types,
        `string|(string[])|undefined`
    */
    setQuery<F extends tm.AnySafeMapper>(f: F): SetQuery<DataT, F>;
    setBody<F extends tm.AnySafeMapper>(f: F): SetBody<DataT, F>;
    /**
        Your header mapper should handle the following types,
        `string|(string[])|undefined`

        Your header key will probably be lowercased.
    */
    setHeader<F extends tm.AnySafeMapper>(f: F): SetHeader<DataT, F>;
    setResponse<F extends tm.AnySafeMapper>(f: F): SetResponse<DataT, F>;
    deepMergeQuery<F extends tm.AnySafeMapper>(f: F): DeepMergeQuery<this, F>;
    isValid(): IsValid<this>;
    assertValid(): void;
}
/**
    Synonym for `Route.Create()`
*/
export declare function route(): Route<DefaultRouteData>;
//# sourceMappingURL=route.d.ts.map