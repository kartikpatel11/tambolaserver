"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var to_type_str_1 = require("./to-type-str");
var strict_equal_1 = require("./strict-equal");
var is_primitive_1 = require("./is-primitive");
var ArrayBufferUtil = require("../array-buffer-util");
var buffer_ctor_1 = require("./buffer-ctor");
function tryDeepMergeImpl(path, a, b) {
    if (strict_equal_1.strictEqual(a, b)) {
        return {
            success: true,
            value: a,
        };
    }
    if (is_primitive_1.isPrimitive(a) || is_primitive_1.isPrimitive(b)) {
        return {
            success: false,
            path: path,
            aValue: a,
            bValue: b,
            message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " and " + to_type_str_1.toTypeStr(b) + "; they are not equal",
            expected: to_type_str_1.toTypeStr(a),
            actualValue: b,
        };
    }
    //We should have object types now.
    if ((typeof a == "function") || (typeof b == "function")) {
        return {
            success: false,
            path: path,
            aValue: a,
            bValue: b,
            message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " and " + to_type_str_1.toTypeStr(b) + "; they are not equal",
            expected: to_type_str_1.toTypeStr(a),
            actualValue: b,
        };
    }
    if ((a instanceof Date) || (b instanceof Date)) {
        if (!(a instanceof Date)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " with Date",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!(b instanceof Date)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge Date with " + to_type_str_1.toTypeStr(b),
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (a.getTime() === b.getTime()) {
            return {
                success: true,
                value: a,
            };
        }
        else {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge dates; they must have the same value",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
    }
    if (buffer_ctor_1.isInstanceOfBuffer(a) || buffer_ctor_1.isInstanceOfBuffer(b)) {
        if (!buffer_ctor_1.isInstanceOfBuffer(a)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " with Buffer",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!buffer_ctor_1.isInstanceOfBuffer(b)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge Buffer with " + to_type_str_1.toTypeStr(b),
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!ArrayBufferUtil.equals(a, b)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge Buffer; they are not equal",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        return {
            success: true,
            value: a,
        };
    }
    if ((a instanceof Uint8Array) || (b instanceof Uint8Array)) {
        if (!(a instanceof Uint8Array)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " with Uint8Array",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!(b instanceof Uint8Array)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge Uint8Array with " + to_type_str_1.toTypeStr(b),
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!ArrayBufferUtil.equals(a, b)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge Uint8Array; they are not equal",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        return {
            success: true,
            value: a,
        };
    }
    if ((a instanceof Array) || (b instanceof Array)) {
        if (!(a instanceof Array)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge " + to_type_str_1.toTypeStr(a) + " with array",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (!(b instanceof Array)) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge array with " + to_type_str_1.toTypeStr(b),
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        if (a.length != b.length) {
            return {
                success: false,
                path: path,
                aValue: a,
                bValue: b,
                message: "Cannot merge arrays of different lengths",
                expected: to_type_str_1.toTypeStr(a),
                actualValue: b,
            };
        }
        var newArray = [];
        for (var i = 0; i < a.length; ++i) {
            var elementResult = tryDeepMergeImpl(path.concat([i.toString()]), a[i], b[i]);
            if (elementResult.success) {
                newArray.push(elementResult.value);
            }
            else {
                return elementResult;
            }
        }
        return {
            success: true,
            value: newArray
        };
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    var mergedKeys = {};
    var newObj = {};
    for (var _i = 0, aKeys_1 = aKeys; _i < aKeys_1.length; _i++) {
        var key = aKeys_1[_i];
        //We can skip a.hasOwnProperty() because Object.keys() ignores parent prototype
        if (mergedKeys[key] === true) {
            continue;
        }
        mergedKeys[key] = true;
        //We do not call `b.hasOwnProperty()` directly
        //because if `b = Object.create(null)`,
        //an `Error` will be thrown
        if (Object.prototype.hasOwnProperty.call(b, key)) {
            var valueResult = tryDeepMergeImpl(path.concat([key]), a[key], b[key]);
            if (valueResult.success) {
                newObj[key] = valueResult.value;
            }
            else {
                return valueResult;
            }
        }
        else {
            newObj[key] = a[key];
        }
    }
    for (var _a = 0, bKeys_1 = bKeys; _a < bKeys_1.length; _a++) {
        var key = bKeys_1[_a];
        //We can skip b.hasOwnProperty() because Object.keys() ignores parent prototype
        if (mergedKeys[key] === true) {
            continue;
        }
        mergedKeys[key] = true;
        //We do not call `a.hasOwnProperty()` directly
        //because if `a = Object.create(null)`,
        //an `Error` will be thrown
        if (Object.prototype.hasOwnProperty.call(a, key)) {
            var valueResult = tryDeepMergeImpl(path.concat([key]), a[key], b[key]);
            if (valueResult.success) {
                newObj[key] = valueResult.value;
            }
            else {
                return valueResult;
            }
        }
        else {
            newObj[key] = b[key];
        }
    }
    return {
        success: true,
        value: newObj,
    };
}
function tryDeepMerge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length == 0) {
        throw new Error("Cannot deep merge zero arguments");
    }
    var result = args[0];
    for (var i = 1; i < args.length; ++i) {
        var implResult = tryDeepMergeImpl([], result, args[i]);
        if (implResult.success) {
            result = implResult.value;
        }
        else {
            return __assign({}, implResult, { aRoot: result, bRoot: args[i] });
        }
    }
    return {
        success: true,
        value: result,
    };
}
exports.tryDeepMerge = tryDeepMerge;
//# sourceMappingURL=try-deep-merge.js.map