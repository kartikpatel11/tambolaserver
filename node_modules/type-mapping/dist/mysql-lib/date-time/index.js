"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fluent_lib_1 = require("../../fluent-lib");
var DateTimeUtil = require("./util");
exports.DateTimeUtil = DateTimeUtil;
var error_util_1 = require("../../error-util");
function dateTime(fractionalSecondPrecision) {
    if (fractionalSecondPrecision === void 0) { fractionalSecondPrecision = 0; }
    return fluent_lib_1.or(fluent_lib_1.string().pipe(function (name, str) {
        try {
            return DateTimeUtil.fromSqlUtc(str, fractionalSecondPrecision);
        }
        catch (err) {
            throw error_util_1.makeMappingError({
                message: name + " must be DATETIME(" + fractionalSecondPrecision + "); " + err.message,
                inputName: name,
                actualValue: str,
                expected: "DATETIME(" + fractionalSecondPrecision + ")",
            });
        }
    }), 
    //To work with JSON serialization
    fluent_lib_1.or(
    //Hopefully, it is a JSON date string
    fluent_lib_1.string(), 
    /*
        We turn the Date object into its JSON representation
        because the Date object may have a millisecond part
        when we do not allow it.

        For example,
        new Date().toJSON() //2019-01-01T00:00:00.123Z

        The above is not assignable to DATETIME(0)
        But is assignable to DATETIME(3)

        -----

        new Date().toJSON() //2019-01-01T00:00:00.120Z

        The above is not assignable to DATETIME(0)
        But is assignable to DATETIME(2) or DATETIME(3)
    */
    fluent_lib_1.instanceOfDate().pipe(function (_name, d) { return d.toJSON(); })).pipe(fluent_lib_1.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{1,3})?Z$/, function (name) {
        return {
            message: name + " must be in the format YYYY-MM-DDTHH:mm:ss.sssZ",
            expected: "YYYY-MM-DDTHH:mm:ss.sssZ",
        };
    }), function (name, str) {
        try {
            str = str.replace("T", " ").replace("Z", "");
            return DateTimeUtil.fromSqlUtc(str, fractionalSecondPrecision);
        }
        catch (err) {
            throw error_util_1.makeMappingError({
                message: name + " must be DATETIME(" + fractionalSecondPrecision + "); " + err.message,
                inputName: name,
                actualValue: str,
                expected: "DATETIME(" + fractionalSecondPrecision + ")",
            });
        }
    })).withExpectedInput();
}
exports.dateTime = dateTime;
//# sourceMappingURL=index.js.map